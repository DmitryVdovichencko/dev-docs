<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/dev-docs/styles.55bab60d2212c7b2dd1d.css">@font-face{font-family:octicons-link;src:url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format("woff")}.markdown-body .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}.markdown-body .anchor{float:left;line-height:1;margin-left:-20px;padding-right:4px}.markdown-body .anchor:focus{outline:none}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;color:#24292e;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;font-size:16px;line-height:1.5;word-wrap:break-word}.markdown-body .pl-c{color:#6a737d}.markdown-body .pl-c1,.markdown-body .pl-s .pl-v{color:#005cc5}.markdown-body .pl-e,.markdown-body .pl-en{color:#6f42c1}.markdown-body .pl-s .pl-s1,.markdown-body .pl-smi{color:#24292e}.markdown-body .pl-ent{color:#22863a}.markdown-body .pl-k{color:#d73a49}.markdown-body .pl-pds,.markdown-body .pl-s,.markdown-body .pl-s .pl-pse .pl-s1,.markdown-body .pl-sr,.markdown-body .pl-sr .pl-cce,.markdown-body .pl-sr .pl-sra,.markdown-body .pl-sr .pl-sre{color:#032f62}.markdown-body .pl-smw,.markdown-body .pl-v{color:#e36209}.markdown-body .pl-bu{color:#b31d28}.markdown-body .pl-ii{background-color:#b31d28;color:#fafbfc}.markdown-body .pl-c2{background-color:#d73a49;color:#fafbfc}.markdown-body .pl-c2:before{content:"^M"}.markdown-body .pl-sr .pl-cce{color:#22863a;font-weight:700}.markdown-body .pl-ml{color:#735c0f}.markdown-body .pl-mh,.markdown-body .pl-mh .pl-en,.markdown-body .pl-ms{color:#005cc5;font-weight:700}.markdown-body .pl-mi{color:#24292e;font-style:italic}.markdown-body .pl-mb{color:#24292e;font-weight:700}.markdown-body .pl-md{background-color:#ffeef0;color:#b31d28}.markdown-body .pl-mi1{background-color:#f0fff4;color:#22863a}.markdown-body .pl-mc{background-color:#ffebda;color:#e36209}.markdown-body .pl-mi2{background-color:#005cc5;color:#f6f8fa}.markdown-body .pl-mdr{color:#6f42c1;font-weight:700}.markdown-body .pl-ba{color:#586069}.markdown-body .pl-sg{color:#959da5}.markdown-body .pl-corl{color:#032f62;text-decoration:underline}.markdown-body details{display:block}.markdown-body summary{display:list-item}.markdown-body a{background-color:transparent}.markdown-body a:active,.markdown-body a:hover{outline-width:0}.markdown-body strong{font-weight:inherit;font-weight:bolder}.markdown-body h1{margin:.67em 0}.markdown-body img{border-style:none}.markdown-body code,.markdown-body kbd,.markdown-body pre{font-family:monospace,monospace;font-size:1em}.markdown-body hr{box-sizing:content-box;overflow:visible}.markdown-body input{font:inherit;margin:0;overflow:visible}.markdown-body [type=checkbox]{box-sizing:border-box;padding:0}.markdown-body *{box-sizing:border-box}.markdown-body input{font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body a{color:#0366d6;text-decoration:none}.markdown-body a:hover{text-decoration:underline}.markdown-body strong{font-weight:600}.markdown-body hr{background:transparent;border-bottom:1px solid #dfe2e5;height:0;margin:15px 0;overflow:hidden}.markdown-body hr:after,.markdown-body hr:before{content:"";display:table}.markdown-body hr:after{clear:both}.markdown-body table{border-collapse:collapse;border-spacing:0}.markdown-body td,.markdown-body th{padding:0}.markdown-body details summary{cursor:pointer}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-bottom:0;margin-top:0}.markdown-body h1{font-size:32px}.markdown-body h1,.markdown-body h2{font-weight:600}.markdown-body h2{font-size:24px}.markdown-body h3{font-size:20px}.markdown-body h3,.markdown-body h4{font-weight:600}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:14px}.markdown-body h5,.markdown-body h6{font-weight:600}.markdown-body h6{font-size:12px}.markdown-body p{margin-bottom:10px;margin-top:0}.markdown-body blockquote{margin:0}.markdown-body ol,.markdown-body ul{margin-bottom:0;margin-top:0;padding-left:0}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ol ol ol,.markdown-body ol ul ol,.markdown-body ul ol ol,.markdown-body ul ul ol{list-style-type:lower-alpha}.markdown-body dd{margin-left:0}.markdown-body code,.markdown-body pre{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px}.markdown-body pre{margin-bottom:0;margin-top:0}.markdown-body input::-webkit-inner-spin-button,.markdown-body input::-webkit-outer-spin-button{-webkit-appearance:none;appearance:none;margin:0}.markdown-body .border{border:1px solid #e1e4e8!important}.markdown-body .border-0{border:0!important}.markdown-body .border-bottom{border-bottom:1px solid #e1e4e8!important}.markdown-body .rounded-1{border-radius:3px!important}.markdown-body .bg-white{background-color:#fff!important}.markdown-body .bg-gray-light{background-color:#fafbfc!important}.markdown-body .text-gray-light{color:#6a737d!important}.markdown-body .mb-0{margin-bottom:0!important}.markdown-body .my-2{margin-bottom:8px!important;margin-top:8px!important}.markdown-body .py-0{padding-bottom:0!important;padding-top:0!important}.markdown-body .py-2{padding-bottom:8px!important;padding-top:8px!important}.markdown-body .pl-3,.markdown-body .px-3{padding-left:16px!important}.markdown-body .px-3{padding-right:16px!important}.markdown-body .f6{font-size:12px!important}.markdown-body .lh-condensed{line-height:1.25!important}.markdown-body .text-bold{font-weight:600!important}.markdown-body:after,.markdown-body:before{content:"";display:table}.markdown-body:after{clear:both}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-bottom:16px;margin-top:0}.markdown-body hr{background-color:#e1e4e8;border:0;height:.25em;margin:24px 0;padding:0}.markdown-body blockquote{border-left:.25em solid #dfe2e5;color:#6a737d;padding:0 1em}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body kbd{border:1px solid #c6cbd1;border-bottom-color:#959da5;box-shadow:inset 0 -1px 0 #959da5;font-size:11px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{font-weight:600;line-height:1.25;margin-bottom:16px;margin-top:24px}.markdown-body h1{font-size:2em}.markdown-body h1,.markdown-body h2{border-bottom:1px solid #eaecef;padding-bottom:.3em}.markdown-body h2{font-size:1.5em}.markdown-body h3{font-size:1.25em}.markdown-body h4{font-size:1em}.markdown-body h5{font-size:.875em}.markdown-body h6{color:#6a737d;font-size:.85em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-bottom:0;margin-top:0}.markdown-body li{word-wrap:break-all}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{font-size:1em;font-style:italic;font-weight:600;margin-top:16px;padding:0}.markdown-body dl dd{margin-bottom:16px;padding:0 16px}.markdown-body table{display:block;overflow:auto;width:100%}.markdown-body table th{font-weight:600}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:6px 13px}.markdown-body table tr{background-color:#fff;border-top:1px solid #c6cbd1}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body img{background-color:#fff;box-sizing:content-box;max-width:100%}.markdown-body img[align=right]{padding-left:20px}.markdown-body img[align=left]{padding-right:20px}.markdown-body code{background-color:rgba(27,31,35,.05);border-radius:3px;font-size:85%;margin:0;padding:.2em .4em}.markdown-body pre{word-wrap:normal}.markdown-body pre>code{background:transparent;border:0;font-size:100%;margin:0;padding:0;white-space:pre;word-break:normal}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{background-color:#f6f8fa;border-radius:3px;font-size:85%;line-height:1.45;overflow:auto;padding:16px}.markdown-body pre code{background-color:transparent;border:0;display:inline;line-height:inherit;margin:0;max-width:auto;overflow:visible;padding:0;word-wrap:normal}.markdown-body .commit-tease-sha{color:#444d56;display:inline-block;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:90%}.markdown-body .blob-wrapper{border-bottom-left-radius:3px;border-bottom-right-radius:3px;overflow-x:auto;overflow-y:hidden}.markdown-body .blob-wrapper-embedded{max-height:240px;overflow-y:auto}.markdown-body .blob-num{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;color:rgba(27,31,35,.3);cursor:pointer;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px;line-height:20px;min-width:50px;padding-left:10px;padding-right:10px;text-align:right;user-select:none;vertical-align:top;white-space:nowrap;width:1%}.markdown-body .blob-num:hover{color:rgba(27,31,35,.6)}.markdown-body .blob-num:before{content:attr(data-line-number)}.markdown-body .blob-code{line-height:20px;padding-left:10px;padding-right:10px;position:relative;vertical-align:top}.markdown-body .blob-code-inner{color:#24292e;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px;overflow:visible;white-space:pre;word-wrap:normal}.markdown-body .pl-token.active,.markdown-body .pl-token:hover{background:#ffea7f;cursor:pointer}.markdown-body kbd{background-color:#fafbfc;border:1px solid #d1d5da;border-bottom-color:#c6cbd1;border-radius:3px;box-shadow:inset 0 -1px 0 #c6cbd1;color:#444d56;display:inline-block;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:10px;padding:3px 5px;vertical-align:middle}.markdown-body :checked+.radio-label{border-color:#0366d6;position:relative;z-index:1}.markdown-body .tab-size[data-tab-size="1"]{-moz-tab-size:1;-o-tab-size:1;tab-size:1}.markdown-body .tab-size[data-tab-size="2"]{-moz-tab-size:2;-o-tab-size:2;tab-size:2}.markdown-body .tab-size[data-tab-size="3"]{-moz-tab-size:3;-o-tab-size:3;tab-size:3}.markdown-body .tab-size[data-tab-size="4"]{-moz-tab-size:4;-o-tab-size:4;tab-size:4}.markdown-body .tab-size[data-tab-size="5"]{-moz-tab-size:5;-o-tab-size:5;tab-size:5}.markdown-body .tab-size[data-tab-size="6"]{-moz-tab-size:6;-o-tab-size:6;tab-size:6}.markdown-body .tab-size[data-tab-size="7"]{-moz-tab-size:7;-o-tab-size:7;tab-size:7}.markdown-body .tab-size[data-tab-size="8"]{-moz-tab-size:8;-o-tab-size:8;tab-size:8}.markdown-body .tab-size[data-tab-size="9"]{-moz-tab-size:9;-o-tab-size:9;tab-size:9}.markdown-body .tab-size[data-tab-size="10"]{-moz-tab-size:10;-o-tab-size:10;tab-size:10}.markdown-body .tab-size[data-tab-size="11"]{-moz-tab-size:11;-o-tab-size:11;tab-size:11}.markdown-body .tab-size[data-tab-size="12"]{-moz-tab-size:12;-o-tab-size:12;tab-size:12}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item+.task-list-item{margin-top:3px}.markdown-body .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}.markdown-body hr{border-bottom-color:#eee}.markdown-body .pl-0{padding-left:0!important}.markdown-body .pl-1{padding-left:4px!important}.markdown-body .pl-2{padding-left:8px!important}.markdown-body .pl-3{padding-left:16px!important}.markdown-body .pl-4{padding-left:24px!important}.markdown-body .pl-5{padding-left:32px!important}.markdown-body .pl-6{padding-left:40px!important}.markdown-body .pl-7{padding-left:48px!important}.markdown-body .pl-8{padding-left:64px!important}.markdown-body .pl-9{padding-left:80px!important}.markdown-body .pl-10{padding-left:96px!important}.markdown-body .pl-11{padding-left:112px!important}.markdown-body .pl-12{padding-left:128px!important}code[class*=language-],pre[class*=language-]{color:#000;background:none;text-shadow:0 1px #fff;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{text-shadow:none;background:#b3d4fc}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#9a6e3a;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.class-name,.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.post-module--post--3ESLj{padding:5px 2rem}body,html{margin:0;padding:0}.layout-module--layout--mFaKB{height:100vh;margin:0 auto;padding:0}.layout-module--content--3nIku{margin:0 auto;max-width:75vw;padding:0 2rem;height:80%;justify-content:space-between}.layout-module--content--3nIku,.layout-module--content__posts--2-sLb{display:flex;flex-flow:column nowrap}@media screen and (min-width:900px){.layout-module--content--3nIku{padding:0 10rem}}.header-module--header--3A712{padding:0 2rem}.header-module--nav--2TcPd{width:100%;display:flex;flex-flow:row wrap;justify-content:flex-end;align-items:center}.header-module--nav__item--3vKbG{margin:5px 10px}</style><meta name="generator" content="Gatsby 2.18.12"/><title data-react-helmet="true">Home | Development Learning Docs</title><meta data-react-helmet="true" name="description" content="Dimetrio development learning docs"/><meta data-react-helmet="true" property="og:title" content="Home"/><meta data-react-helmet="true" property="og:description" content="Dimetrio development learning docs"/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:creator" content="@DmitryVdovichenko"/><meta data-react-helmet="true" name="twitter:title" content="Home"/><meta data-react-helmet="true" name="twitter:description" content="Dimetrio development learning docs"/><link as="script" rel="preload" href="/dev-docs/webpack-runtime-3f59d165217ef71e6555.js"/><link as="script" rel="preload" href="/dev-docs/commons-219ea28c1c39fae67d6f.js"/><link as="script" rel="preload" href="/dev-docs/app-3cab7f4d358d3b42dcb7.js"/><link as="script" rel="preload" href="/dev-docs/styles-3251c89baff59e4ed99c.js"/><link as="script" rel="preload" href="/dev-docs/component---src-templates-blog-post-js-4b73db3022adcfffa7bc.js"/><link as="fetch" rel="preload" href="/dev-docs/page-data/pages/posts/you-dont-know-JS-types/page-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group" id="gatsby-focus-wrapper"><div class="markdown-body layout-module--layout--mFaKB"><header class="header-module--header--3A712"><h1><a href="/dev-docs/"><span>Development Learning Docs <!-- --> </span><span role="img" aria-label="memo">📝</span><span role="img" aria-label="book">📖</span><span role="img" aria-label="mortar_board">🎓</span><span role="img" aria-label="computer">💻</span></a></h1><nav class="header-module--nav--2TcPd"><div class="header-module--nav__item--3vKbG"><a href="/dev-docs/tags/js">JavaScript</a></div><div class="header-module--nav__item--3vKbG"><a href="/dev-docs/tags/react">React</a></div><div class="header-module--nav__item--3vKbG"><a href="/dev-docs/tags/redux">Redux</a></div></nav></header><div class="layout-module--content--3nIku"><main class="layout-module--content__posts--2-sLb"><div class="post-module--post--3ESLj"><article class="markdown-body"><h1>Вы не знаете JS. Типы данных и грамматика. Значения</h1><p>Перевод Главы 2 книги Кайла Симпсона <a href="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/types-grammar/ch2.md">&quot;Вы не знаете JS. Типы данных и грамматика. Значения&quot;</a>.  </p><p><code class="language-text">array</code>, <code class="language-text">string</code>, и <code class="language-text">number</code> являются основными составными элементами любой программы, но в JavaScript, при работе с этими типами данных, есть несколько особенностей, которые могут смутить или запутать вас.</p><p>Давайте посмотрим на несколько встроенных типов JS, и разберемся как мы можем полностью понять и корректно использовать их поведение.</p><h2>Массивы</h2><p>Если сравнивать с другими строго-типизированными языками, в JavaScript массивы - всего  лишь контейнеры для любых типов значений, начиная от  <code class="language-text">string</code> до <code class="language-text">number</code> , <code class="language-text">object</code> и даже других <code class="language-text">array</code> (с помощью которых можно создавать многомерные массивы).</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>		<span class="token comment">// 3</span>
a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">;</span>		<span class="token comment">// true</span>
a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">;</span>	<span class="token comment">// true</span></code></pre></div><p>Вам не нужно предварительно устанавливать размер <code class="language-text">array</code> (подробнее в &quot;Массивы&quot; Глава 3), вы можете просто объявить их и добавлять значения когда вам нужно:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>	<span class="token comment">// 0</span>

a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>	<span class="token comment">// 3</span></code></pre></div><p><strong>Предупреждение:</strong> Используя <code class="language-text">delete</code> для значения <code class="language-text">array</code> будет удалена ячейка <code class="language-text">array</code> с этим значением, но даже если вы удалите последний элемент таким способом, это <strong>НЕ</strong> обновит свойство <code class="language-text">length</code> , так что будьте осторожны! Работа оператора <code class="language-text">delete</code> более детально будет рассмотрена в Главе 5.</p><p>Будьте осторожны при создании &quot;разрозненных&quot; массивов (оставляя или создавая пустые/пропущенные ячейки):</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">// ячейка `a[1]` отсутствует</span>
a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">// undefined</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>	<span class="token comment">// 3</span></code></pre></div><p>Такой код может привести к странному поведению &quot;пустых ячеек&quot; оставленных между элементами массива. Пустой слот со значением <code class="language-text">undefined</code> внутри, ведет себя не так же как явно объявленный эдемент массива (<code class="language-text">a[1] = undefined</code>). Подробнее в главе 3 &quot;Массивы&quot;.</p><p>Массивы <code class="language-text">array</code>s проиндексированы числами (как и ожидается), но хитрость в том, что они могут иметь индекс в виде  строки <code class="language-text">string</code> ключ/свойство могут быть добавлены к массиву (но такие свойства не будут посчитаны в длине массива <code class="language-text">length</code>):</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token string">&quot;foobar&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>		<span class="token comment">// 1</span>
a<span class="token punctuation">[</span><span class="token string">&quot;foobar&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">// 2</span>
a<span class="token punctuation">.</span>foobar<span class="token punctuation">;</span>		<span class="token comment">// 2</span></code></pre></div><p>Как бы там ни было, нужно быть осторожнее при использовании индексов массива в виде <code class="language-text">string</code> , т.к. это значение может быть преобразовано в тип <code class="language-text">number</code>, потому что использование индекса <code class="language-text">number</code> для массива предпочтительнее чем <code class="language-text">string</code>!</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

a<span class="token punctuation">[</span><span class="token string">&quot;13&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 14</span></code></pre></div><p>В общем, это не самая лучшая идея использовать пару <code class="language-text">string</code> ключ/свойство как элемент массива <code class="language-text">array</code>. Используйте <code class="language-text">object</code> для хранения пар ключ/свойство, а массивы <code class="language-text">array</code>s приберегите для хранения значений в ячейках с числовыми индексами.</p><h3>Массивоподобные</h3><p>Бывают случаи когда нужно преобразовать  массивоподобное значение (пронумерованную коллекцию значений) в настоящий массив <code class="language-text">array</code>, обычно таким образом вы сможете применить методы массива (такие как <code class="language-text">indexOf(..)</code>, <code class="language-text">concat(..)</code>, <code class="language-text">forEach(..)</code>, etc.) к коллекции значений.</p><p>Например, различные DOM запросы возвращают список DOM элементов который не является настоящим массивом <code class="language-text">array</code>, но, при этом он достаточно похож на массив для преобразования. Другой общеизвестный пример - когда функция предоставляет свои аргументы <code class="language-text">arguments</code> в виде массивоподобного объекта (в ES6, считается устаревшим), чтобы получить доступ к списку аргументов.</p><p>Один из самых распространенных способов осуществить такое преобразование одолжить метод <code class="language-text">slice(..)</code> для значения:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>
	arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token string">&quot;bam&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> arr <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;baz&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&quot;bar&quot;,&quot;baz&quot;,&quot;bam&quot;]</span></code></pre></div><p>Если <code class="language-text">slice()</code> вызван без каких-либо параметров, как в примере выше, стандартные значения его параметров позволят продублировать массив <code class="language-text">array</code> (а в нашем случае , массивоподобное значение).</p><p>В ES6, есть встроенный метод <code class="language-text">Array.from(..)</code> который при вызове выполнит то же самое:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token operator">...</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">...</span></code></pre></div><p><strong>Примечание:</strong> <code class="language-text">Array.from(..)</code> имеет несколько мощных возможностей, детально о них рассказано в книге <em>ES6 и не только</em> данной серии.</p><h2>Строки</h2><p>Есть общее мнение, что строки <code class="language-text">string</code> являются всего лишь массивами <code class="language-text">array</code> из символов. Пока мы решаем можно или нельзя использовать <code class="language-text">array</code>, важно осознавать что JavaScript <code class="language-text">string</code>на самом деле не то же самое что массивы <code class="language-text">array</code> символов. Это сходство по большей части поверхностное.</p><p>Например, давайте сравним два значения:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;f&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;o&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;o&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></div><p>Строки имеют поверхностные сходства по отношению к массивам и массивоподобным, такие как -- например, оба из них имеют свойство <code class="language-text">length</code>,метод <code class="language-text">indexOf(..)</code> (<code class="language-text">array</code> только в ES5), и метод <code class="language-text">concat(..)</code>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>							<span class="token comment">// 3</span>
b<span class="token punctuation">.</span>length<span class="token punctuation">;</span>							<span class="token comment">// 3</span>

a<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span> <span class="token string">&quot;o&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 1</span>
b<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span> <span class="token string">&quot;o&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 1</span>

<span class="token keyword">var</span> c <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span> <span class="token string">&quot;bar&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// &quot;foobar&quot;</span>
<span class="token keyword">var</span> d <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;r&quot;</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// [&quot;f&quot;,&quot;o&quot;,&quot;o&quot;,&quot;b&quot;,&quot;a&quot;,&quot;r&quot;]</span>

a <span class="token operator">===</span> c<span class="token punctuation">;</span>							<span class="token comment">// false</span>
b <span class="token operator">===</span> d<span class="token punctuation">;</span>							<span class="token comment">// false</span>

a<span class="token punctuation">;</span>									<span class="token comment">// &quot;foo&quot;</span>
b<span class="token punctuation">;</span>									<span class="token comment">// [&quot;f&quot;,&quot;o&quot;,&quot;o&quot;]</span></code></pre></div><p>Итак строки по большей части это &quot;массивы символов&quot;, верно? <strong>НЕ совсем</strong>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;O&quot;</span><span class="token punctuation">;</span>
b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;O&quot;</span><span class="token punctuation">;</span>

a<span class="token punctuation">;</span> <span class="token comment">// &quot;foo&quot;</span>
b<span class="token punctuation">;</span> <span class="token comment">// [&quot;f&quot;,&quot;O&quot;,&quot;o&quot;]</span></code></pre></div><p>В JavaScript строки <code class="language-text">string</code> неизменяемы, тогда как массивы <code class="language-text">array</code> достаточно изменяемы. Более того форма доступа к символу строки вида <code class="language-text">a[1]</code>  не совсем правильный JavaScript. Старые версии IE не разрешают такой синтаксис (в новых версиях IE это работает). Вместо него нужно использовать <em>корректный</em> способ -  <code class="language-text">a.charAt(1)</code>.</p><p>Еще одним подследствием неизменяемости строк <code class="language-text">string</code> является то что ни один метод строки <code class="language-text">string</code> меняющий ее содержимое не может делать это по месту, скорее метод создаст и вернет новые строки. И напротив, большинство методов изменяющих содержимое массива <code class="language-text">array</code> действительно <em>делают</em> изменения по месту.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">c <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a <span class="token operator">===</span> c<span class="token punctuation">;</span>	<span class="token comment">// false</span>
a<span class="token punctuation">;</span>			<span class="token comment">// &quot;foo&quot;</span>
c<span class="token punctuation">;</span>			<span class="token comment">// &quot;FOO&quot;</span>

b<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token string">&quot;!&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">;</span>			<span class="token comment">// [&quot;f&quot;,&quot;O&quot;,&quot;o&quot;,&quot;!&quot;]</span></code></pre></div><p>Также многие из методов массива <code class="language-text">array</code>, которые могут быть полезны при работе со строками <code class="language-text">string</code> вообще для них недоступны, но мы можем &quot;одолжить&quot; неизменяющие методы массива <code class="language-text">array</code> для нашей строки <code class="language-text">string</code>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">a<span class="token punctuation">.</span>join<span class="token punctuation">;</span>			<span class="token comment">// undefined</span>
a<span class="token punctuation">.</span>map<span class="token punctuation">;</span>			<span class="token comment">// undefined</span>

<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> <span class="token string">&quot;-&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;.&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

c<span class="token punctuation">;</span>				<span class="token comment">// &quot;f-o-o&quot;</span>
d<span class="token punctuation">;</span>				<span class="token comment">// &quot;F.O.O.&quot;</span></code></pre></div><p>Давайте возьмем другой пример: реверсируем строку <code class="language-text">string</code> (кстати, это довольно тривиальный общий вопрос на  JavaScript собеседованиях!). У массивов <code class="language-text">array</code>есть метод <code class="language-text">reverse()</code> осуществляюший изменение по месту, но для строки <code class="language-text">string</code>такого метода нет:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">a<span class="token punctuation">.</span>reverse<span class="token punctuation">;</span>		<span class="token comment">// undefined</span>

b<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// [&quot;!&quot;,&quot;o&quot;,&quot;O&quot;,&quot;f&quot;]</span>
b<span class="token punctuation">;</span>				<span class="token comment">// [&quot;!&quot;,&quot;o&quot;,&quot;O&quot;,&quot;f&quot;]</span></code></pre></div><p>К несчастью, это &quot;одалживание&quot; не сработает с методами изменяющими массив <code class="language-text">array</code>, потому что строки <code class="language-text">string</code> неизменяемы и поэтому не могут быть изменены по месту:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// все еще возвращаем объект-обертку String (подробнее в Главе 3)</span>
<span class="token comment">// для &quot;foo&quot; :(</span></code></pre></div><p>Другое временное решение (хак) отконвертировать строку <code class="language-text">string</code> в массив <code class="language-text">array</code>, выполнить желаемое действие, и затем отконвертировать обратно в строку <code class="language-text">string</code>.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> c <span class="token operator">=</span> a
	<span class="token comment">// разбиваем `a` на массив символов</span>
	<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">)</span>
	<span class="token comment">// реверсируем массив символов</span>
	<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// объединяем массив символов обратно в строку</span>
	<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

c<span class="token punctuation">;</span> <span class="token comment">// &quot;oof&quot;</span></code></pre></div><p>Если кажется, что это выглядит безобразно, так и есть. Тем не менее, <em>это работает</em> для простых строк <code class="language-text">string</code>, так что, если вам нужно &quot;склепать&quot; что-нибудь по быстрому, часто такой подход позволит выполнить работу.</p><p><strong>Предупреждение:</strong> Будьте осторожны! Этот подход <strong>не работает</strong> для строк <code class="language-text">string</code> со сложными (unicode) символами в них (astral symbols, multibyte characters, etc.). Вам потребуются более сложные библиотеки которые распознают unicode символы для правильного выполнения подобных операций. Подробнее можно посмотреть в работе Mathias Bynens&#x27;: <em>Esrever</em> (<a href="https://github.com/mathiasbynens/esrever">https://github.com/mathiasbynens/esrever</a>).</p><p>Хотя с другой стороны: если вы чаще работаете с вашими &quot;строками&quot;,  интерпритируя их как <em>массивы символов</em>, возможно лучше просто записывать их в массив <code class="language-text">array</code>вместо строк <code class="language-text">string</code>.Возможно вы избавите себя от хлопот при переводе строки <code class="language-text">string</code> в массив <code class="language-text">array</code>каждый раз. Вы всегда можете вызвать <code class="language-text">join(&quot;&quot;)</code> для массива <code class="language-text">array</code> <em>символов</em> когда вам понадобится представление в ивде строки <code class="language-text">string</code>.</p><h2>Числа</h2><p>В JavaScript есть один числовой тип: <code class="language-text">number</code>. Этот тип включает в себя как &quot;целые&quot; (&quot;integer&quot;) значения так и десятичные дробные числа. Я заключил &quot;целые&quot; (&quot;integer&quot;) в кавычки, потому что в JS это понятие подвергается критике, поскольку здесь нет реально целых значений, как в других языках программирования. Возможно в будущем это изменится, но сейчас, у нас просто есть тип <code class="language-text">number</code>для всего.</p><p>Итак, в JS, &quot;целое&quot; (&quot;integer&quot;) это просто числовое значение, которое не имеет десятичной составляющей после запятой . Так нпаример, <code class="language-text">42.0</code> более может считаться &quot;целым&quot;(&quot;integer&quot;), чем <code class="language-text">42</code>.</p><p>Как и в большинстве современных языков, включая практически все скриптовые языки, реализация чисел <code class="language-text">number</code> в JavaScript&#x27;основана на стандарте &quot;IEEE 754&quot;, котороый часто называют &quot;числа с плавающей точкой&quot; (&quot;floating-point&quot;). JavaScript особенно использует формат &quot;двойной степени точности&quot; (как &quot;64-битные в бинарном формате&quot;) этого стандарта.</p><p>В интернете есть множество статей о подробных деталях того, как бинарные числа с плавющей точкой записываются в память, и последствия выбора таких чисел. Т.к. понимание того как работает запись в память не строго необходимо для того чтобы корректно использовать числа <code class="language-text">number</code> в JS, мы оставим это упражнение для заинтересованного читателя, если вы захотите более детально разобраться со стандартом IEEE 754.</p><h3>Числовой синтаксис</h3><p>Чичловые литералы в JavaScript в большинстве представлены как литералы десятичных дробей. Например:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">42.3</span><span class="token punctuation">;</span></code></pre></div><p>Если целая часть дробного числа - <code class="language-text">0</code>, можно ее опустить:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0.42</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">.42</span><span class="token punctuation">;</span></code></pre></div><p>Аналогично, если дробная часть после точки <code class="language-text">.</code>, - <code class="language-text">0</code>, можно ее опустить:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42.0</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">42.</span><span class="token punctuation">;</span></code></pre></div><p><strong>Предупреждение:</strong> <code class="language-text">42.</code> выглядит достаточно необычно, и возможно это не лучшая идея если вы хотите избежать недопонимания со стороны других людей при работе с вашим кодом. Но, в любом случае, это корректная запись.</p><p>По умолчанию, большинство чисел <code class="language-text">number</code> выводятся как десятичные дроби, с удаленными нулями <code class="language-text">0</code> в конце дробной части. Так:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42.300</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">42.0</span><span class="token punctuation">;</span>

a<span class="token punctuation">;</span> <span class="token comment">// 42.3</span>
b<span class="token punctuation">;</span> <span class="token comment">// 42</span></code></pre></div><p>Очень большие или очень маленькие числа <code class="language-text">number</code> по умолчанию выводятся в экспоненциальной форме, также как и результат метода <code class="language-text">toExponential()</code>, например:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">5E10</span><span class="token punctuation">;</span>
a<span class="token punctuation">;</span>					<span class="token comment">// 50000000000</span>
a<span class="token punctuation">.</span><span class="token function">toExponential</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// &quot;5e+10&quot;</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">*</span> a<span class="token punctuation">;</span>
b<span class="token punctuation">;</span>					<span class="token comment">// 2.5e+21</span>

<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> a<span class="token punctuation">;</span>
c<span class="token punctuation">;</span>					<span class="token comment">// 2e-11</span></code></pre></div><p>Т.к. числовые значения <code class="language-text">number</code> могут быть помещены в объект - обертку <code class="language-text">Number</code> (подробнее Глава 3), числовые значения <code class="language-text">number</code> могут получать методы встроенные в <code class="language-text">Number.prototype</code> (подробнее Глава 3). Например, метод <code class="language-text">toFixed(..)</code> позволяет вам определить с точностью до скольки знаков после запятой вывести дробную часть:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42.59</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;43&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.6&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.59&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.590&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.5900&quot;</span></code></pre></div><p>Заметьте что результат - строковлое <code class="language-text">string</code> представление числа <code class="language-text">number</code>, и таким образом <code class="language-text">0</code>- будет добавлено справа если вам понадобится больше знаков после запятой, чем есть сейчас.</p><p><code class="language-text">toPrecision(..)</code> похожий метод, но он определяет сколько <em>цифровых знаков</em> должно использоваться в выводимом значении:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42.59</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;4e+1&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;43&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.6&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.59&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span> <span class="token number">5</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.590&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span> <span class="token number">6</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.5900&quot;</span></code></pre></div><p>Вам не обязательно использовать переменные для хранения чисел, чтобы применить эти методы; вы можете применять методы прямо к числовым литералам <code class="language-text">number</code>. Но, будьте осторожны с оператором <code class="language-text">.</code>. Т.к. <code class="language-text">.</code> это еще и числовой оператор, и, если есть такая  возможность, он в первую очередь будет интепритирован как часть числового литерала <code class="language-text">number</code>, вместо того чтобы получать доступ к свойству.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// неправильный ситнтакс:</span>
<span class="token number">42.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// SyntaxError</span>

<span class="token comment">// это корректное обращение к методам:</span>
<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// &quot;42.000&quot;</span>
<span class="token number">0.42</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// &quot;0.420&quot;</span>
<span class="token number">42.</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// &quot;42.000&quot;</span></code></pre></div><p><code class="language-text">42.toFixed(3)</code> неверный синтакс, потому что <code class="language-text">.</code> станет частью числового литерала <code class="language-text">42.</code> (такая запись корректна -- смотрите выше!), и тогда оператор <code class="language-text">.</code> который должен получить доступ к методу <code class="language-text">.toFixed</code> отсутствует.</p><p><code class="language-text">42..toFixed(3)</code> работает т.к. первый оператор <code class="language-text">.</code> часть чилового литерала <code class="language-text">number</code> второая <code class="language-text">.</code> оператор доступа к свойству. Но, возможно это выглядит странно, и на самом деле очень редко можно увидеть что-то подобное в реальном JavaScript коде. Фактически, это нестандартно -- применять методы прямо к примитивным значениям. Нестандартно не значит <em>плохо</em> или <em>неправильно</em>.</p><p><strong>Примечание:</strong> Есть библиотеки расширяющие встроенные методы <code class="language-text">Number.prototype</code> (подробнее Глава 3) для поддержки операций над/с числами <code class="language-text">number</code>, и в этих случаях, совершенно правильно использовать <code class="language-text">10..makeItRain()</code> чтобы отключить 10-секундную анимацию денежного дождя, или еще что-нибудь такое же глупое.</p><p>Также технически корректной будет такая запись (заметьте пробел):</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token number">42</span> <span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.000&quot;</span></code></pre></div><p>Тем не менее, с числовыми литералами <code class="language-text">number</code> особенно, <strong>это черезвычайно запутанный стиль кода</strong> и он не преследует иных цедей кроме как запутать разработчиков при работе с кодом (в том числе и вас в будущем). Избегайте этого.</p><p>Числа <code class="language-text">number</code> также могут быть представлены в экспоненциальной форме, которую обычно используют для представления больших чисел <code class="language-text">number</code> таких как:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> onethousand <span class="token operator">=</span> <span class="token number">1E3</span><span class="token punctuation">;</span>						<span class="token comment">// means 1 * 10^3</span>
<span class="token keyword">var</span> onemilliononehundredthousand <span class="token operator">=</span> <span class="token number">1.1E6</span><span class="token punctuation">;</span>	<span class="token comment">// means 1.1 * 10^6</span></code></pre></div><p>Числовые литералы <code class="language-text">number</code> могут быть также выражены в других формах, таких как, двоичная, восьмеричная, и шестнадцатиричная.</p><p>Эти форматы работают в текущей версии JavaScript:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token number">0xf3</span><span class="token punctuation">;</span> <span class="token comment">// шестнадцатиричная для: 243</span>
<span class="token number">0Xf3</span><span class="token punctuation">;</span> <span class="token comment">// то же самое</span>

<span class="token number">0363</span><span class="token punctuation">;</span> <span class="token comment">// восьмеричная для: 243</span></code></pre></div><p><strong>Примечание:</strong> Начиная с ES6 с включенным <code class="language-text">strict</code> режимом, восьмеричная форма <code class="language-text">0363</code> больше не разрешена (смотрите ниже новую форму). Форма <code class="language-text">0363</code> все еще разрешена в <code class="language-text">non-strict</code> режиме, но в любом случае нужно прекратить ее использовать, чтобы использовать современный подход (и потому что пора бы использовать <code class="language-text">strict</code> режим уже сейчас!).</p><p>Для ES6, доступны новые формы записи:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token number">0o363</span><span class="token punctuation">;</span>		<span class="token comment">// восьмеричная для: 243</span>
<span class="token number">0O363</span><span class="token punctuation">;</span>		<span class="token comment">// то же самое</span>

<span class="token number">0b11110011</span><span class="token punctuation">;</span>	<span class="token comment">// двоичная для: 243</span>
<span class="token number">0B11110011</span><span class="token punctuation">;</span> <span class="token comment">// то же самое</span></code></pre></div><p>И пожалуйста окажите вашим коллегам - разработчикам услугу: никогда не используйте форму вида <code class="language-text">0O363</code>. <code class="language-text">0</code> перед заглавной <code class="language-text">O</code> может лишь вызвать затруднение при чтении кода. Всегда используйте нижний регистр в подобных формах: <code class="language-text">0x</code>, <code class="language-text">0b</code>, и <code class="language-text">0o</code>.</p><h3>Маленькие дробные числа</h3><p>Самый известный побочный эффект от использования бинарной формы чисел с плавающей точкой (которая, как мы помним, справедлива для <strong>всех</strong> языков использующих стандарт IEEE 754 -- не <em>только</em> JavaScript как многие привыкли предполагать) это:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">===</span> <span class="token number">0.3</span><span class="token punctuation">;</span> <span class="token comment">// false</span></code></pre></div><p>Математически, что результатом выражения должно быть <code class="language-text">true</code>. Почему же в результате получается <code class="language-text">false</code>?</p><p>Если по простому, представления чисел <code class="language-text">0.1</code> и <code class="language-text">0.2</code> в бинарном виде с плавающей точкой не совсем точные, поэтому когда мы их складываем, результат не совсем <code class="language-text">0.3</code>. Это <strong>действительно</strong> близко: <code class="language-text">0.30000000000000004</code>, но если сравнение не прошло, &quot;близко&quot; уже не имеет значения.</p><p><strong>Примечание:</strong> Должен ли JavaScript перейти на другую реализацию числового типа <code class="language-text">number</code> которая имеет точные представления для всех значений? Некоторые так думают. За все годы появлялось много альтернатив. Никакие из них до сих пор не были утверждены, и возможно никогда не будут. Кажется что это также легко, как просто поднять руку и сказать &quot;Да исправьте вы уже этот баг!&quot;, но это вовсе не так. Если бы это было легко, это определенно было бы имправлено намного раньше.</p><p>Сейчас, вопрос в том, что если есть числа <code class="language-text">number</code> для которых нельзя быть <em>уверенным</em> в их точности, может нам совсем не стоит испльзовать числа <code class="language-text">number</code>? <strong>Конечно нет.</strong></p><p>Есть несколько случаев применения чисел, где нужно быть осторожными, особенно имея дело с дробными числами. Также есть достаточно (возможно большинство?) случаев когда мы имеем дело только с целыми числами (&quot;integers&quot;), и более того, работаем только с числами максимум до миллиона или триллиона. Такие случаи применения чисел всегда были, и будут, <strong>превосходно безопасными</strong> для проведения числовых операций в JS.</p><p>Ео что если нам <em>было</em> нужно сравнить два числа <code class="language-text">number</code> таких как <code class="language-text">0.1 + 0.2</code> и <code class="language-text">0.3</code>, зная что обычный тест на равенство не сработает?</p><p>Самая общепринятая практикаиспользование миниатюрной &quot;ошибки округления&quot; как <em>допуска</em> для сравнения. Это малюсенькое значение часто называют &quot;машинной эпсилон,&quot; которое составляет <code class="language-text">2^-52</code> (<code class="language-text">2.220446049250313e-16</code>) для числового типа <code class="language-text">number</code> в JavaScript.</p><p>В ES6, <code class="language-text">Number.EPSILON</code> определено заранее этим пороговым значением, так что если вы хотите его использовать, нужно применить полифилл для определения порогового значения для стандартов до-ES6:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div><p>Мы можем использовать это значение <code class="language-text">Number.EPSILON</code> для проверки двух чисел <code class="language-text">number</code>на &quot;равенство&quot; (с учетом допуска ошибки округления):</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">numbersCloseEnoughToEqual</span><span class="token punctuation">(</span><span class="token parameter">n1<span class="token punctuation">,</span>n2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span> n1 <span class="token operator">-</span> n2 <span class="token punctuation">)</span> <span class="token operator">&lt;</span> Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">0.3</span><span class="token punctuation">;</span>

<span class="token function">numbersCloseEnoughToEqual</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// true</span>
<span class="token function">numbersCloseEnoughToEqual</span><span class="token punctuation">(</span> <span class="token number">0.0000001</span><span class="token punctuation">,</span> <span class="token number">0.0000002</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// false</span></code></pre></div><p>Максимальное значение числа с плавающей точкой приблизительно <code class="language-text">1.798e+308</code> (реально огромное число!), определено как <code class="language-text">Number.MAX_VALUE</code>. Минимальное значение, <code class="language-text">Number.MIN_VALUE</code> приблизительно <code class="language-text">5e-324</code>, оно положительное, но очень близко к нулю!</p><h3>Безопасные диапазоны целых чисел</h3><p>Из-за представления чисел <code class="language-text">number</code>в JS, существует диапазон &quot;безопасных&quot; значений для всех чисел <code class="language-text">number</code> &quot;integers&quot;, и он существенно меньше значения <code class="language-text">Number.MAX_VALUE</code>.</p><p>Максимальное целое число, которое может быть &quot;безопасно&quot; представлено (это означает гарантию того, что запрашиваемое значение будет представлено совершенно определенно) это <code class="language-text">2^53 - 1</code>, что составляет <code class="language-text">9007199254740991</code>. Если вы добавите запятые, то увидите что это немного больше 9 квадридллионов. Так что это чертовски много для верхнего диапазона чисел <code class="language-text">number</code>.</p><p>Это значение автоматически предопределенно в ES6, как <code class="language-text">Number.MAX_SAFE_INTEGER</code>. Ожидаемо, минимальное значение, <code class="language-text">-9007199254740991</code>, соответственно предопрелено в ES6 как <code class="language-text">Number.MIN_SAFE_INTEGER</code>.</p><p>Чаще всего JS программы могут столкнуться с такими большими чилами, когда имеют дело с 64-битными ID баз данных, и т.п.. 64-битные не могут быть точно представлены типом <code class="language-text">number</code>, так что они должны быть записаны (и переданы в/из) JavaScript с помощью строкового <code class="language-text">string</code> представления.</p><p>Математические операции с ID <code class="language-text">number</code> значениями (кроме сравнения, которое отлично пройдет со строками <code class="language-text">string</code>) обычно не выполняются, к счастью. Но если вам <em>необходимо</em> выполнить математическую операцию с очень большими числами, сейчас вы можете использовать утилиту <em>big number</em>. Поддержка больших чисел может быть реализована в будущих стандартах JavaScript.</p><h3>Проверяем является ли число целым</h3><p>Чтобы проверить,является ли число целым, вы можете использовать специальный ES6-метод <code class="language-text">Number.isInteger(..)</code>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">Number<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// true</span>
Number<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span> <span class="token number">42.000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// true</span>
Number<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span> <span class="token number">42.3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// false</span></code></pre></div><p>Полифилл для <code class="language-text">Number.isInteger(..)</code> для стандартов до-ES6:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Number<span class="token punctuation">.</span>isInteger<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Number<span class="token punctuation">.</span><span class="token function-variable function">isInteger</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token keyword">typeof</span> num <span class="token operator">==</span> <span class="token string">&quot;number&quot;</span> <span class="token operator">&amp;&amp;</span> num <span class="token operator">%</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div><p>Для проверки на нахождение числа в безопасном диапазоне <em>safe integer</em>, используется ES6-метод  <code class="language-text">Number.isSafeInteger(..)</code>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">Number<span class="token punctuation">.</span><span class="token function">isSafeInteger</span><span class="token punctuation">(</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// true</span>
Number<span class="token punctuation">.</span><span class="token function">isSafeInteger</span><span class="token punctuation">(</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">53</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// false</span>
Number<span class="token punctuation">.</span><span class="token function">isSafeInteger</span><span class="token punctuation">(</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">53</span> <span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// true</span></code></pre></div><p>Полифилл для <code class="language-text">Number.isSafeInteger(..)</code> для стандартов до-ES6:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Number<span class="token punctuation">.</span>isSafeInteger<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Number<span class="token punctuation">.</span><span class="token function-variable function">isSafeInteger</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> Number<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span> num <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
			Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span> num <span class="token punctuation">)</span> <span class="token operator">&lt;=</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div><h3>32-битные целые числа (со знаком)</h3><p>Пока целые числа могут быть приблизительно до 9 квадриллионов (53 бита), есть несколько числовых операторов (например побитовые операторы), которые определены для 32-битных чисел <code class="language-text">number</code>, так &quot;безопасный диапазон&quot; для чисел <code class="language-text">number</code> используемый в таких случаях намного меньше.</p><p>Диапазоном является от <code class="language-text">Math.pow(-2,31)</code> (<code class="language-text">-2147483648</code>, около -2.1 милллиардов) до <code class="language-text">Math.pow(2,31)-1</code> (<code class="language-text">2147483647</code>, около +2.1 миллиардов).</p><p>Чтобы записать число <code class="language-text">number</code> из переменной <code class="language-text">a</code> в 32-битное целое число, используем <code class="language-text">a | 0</code>. Это сработает т.к.  <code class="language-text">|</code> побитовый оператор и работает только с 32-битными целыми числами (это означает что он будет работать только с 32 битами, а остальные биты будут утеряны). Ну, а &quot;ИЛИ&quot; с нулем побитовый оператор, который не проводит операций с битами.</p><p><strong>Примечание:</strong> Определенные специальные значения (о которых будет расказано далее) такие как <code class="language-text">NaN</code> и  <code class="language-text">Infinity</code> не являются &quot;32-битными безопасными значениями&quot; и в случае передачи этих значений побитовому оператору, будет применен абстрактный оператор  <code class="language-text">ToInt32</code> (смотрите главу 4) результатом которого будет значение<code class="language-text">+0</code> для последующего применения побитового оператора.</p><h2>Специальные значения</h2><p>Есть несколько специальных значений, которые распространяются на все типы, и с которыми <em>внимательный</em> JS разработчик должен быть осторожен, и использовать их по назначению.</p><h3>Отстуствие значения</h3><p>Для типа <code class="language-text">undefined</code>, есть только одно значение: <code class="language-text">undefined</code>. Для типа <code class="language-text">null</code>, есть только одно значение: <code class="language-text">null</code>. Итак для них обоих, есть свой тип и свое значение.</p><p>И <code class="language-text">undefined</code> и <code class="language-text">null</code> часто считаются взаимозаменяемыми, как либо &quot;пустое&quot; значение, либо его &quot;отсутствие&quot;. Другие разработчики различают их в соответствиис их особенностями. Например:</p><ul><li><code class="language-text">null</code> пустое значение</li><li><code class="language-text">undefined</code> остуствующее значение</li></ul><p>Или:</p><ul><li><code class="language-text">undefined</code> значение пока не присвоено</li><li><code class="language-text">null</code> значение есть и там ничего не содержится</li></ul><p>Независимо от того, как вы &quot;определяете&quot; и используете эти два значения, <code class="language-text">null</code> это специальное ключевое слово, не является идентификатором, и таким образом нельзя его использовать для назначения переменной (зачем вообще это делать!?). Как бы там ни было, <code class="language-text">undefined</code> <em>является</em> (к несчастью) идентификатором. Увы и ах.</p><h3>Undefined</h3><p>В нестрогом режиме non-<code class="language-text">strict</code>, действительно есть возможность (хоть это и срезвчайно плохая идея!) присваивать значение глобальному идентификатору <code class="language-text">undefined</code> :</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// очень плохая идея!</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// TypeError!</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div><p>Как в нестрогом non-<code class="language-text">strict</code> так и в строгом <code class="language-text">strict</code> режимах, тем не менее, вы можете создать локальную переменную <code class="language-text">undefined</code>. Но, еше раз, это ужасная идея!</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">var</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">undefined</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div><p><strong>Настоящие друзья никогда не позволят друзьям переназначить <code class="language-text">undefined</code>.</strong> Никогда.</p><h4>Оператор <code class="language-text">void</code></h4><p>Пока <code class="language-text">undefined</code> является встроенным идентификатором который содержит (если только кто-нибудь это не изменил -- см. выше!) встроенное значение <code class="language-text">undefined</code>, другой способ получить это значение - оператор <code class="language-text">void</code>.</p><p>Выражение <code class="language-text">void ___</code> &quot;аннулирует&quot; любое значение, так что результатом выражения всегда будет являться значение <code class="language-text">undefined</code>. Это выражение не изменяет действующее значение; оно просто дает нам уверенность в том, что мы не получим назад другого значения после применения оператора.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">void</span> a<span class="token punctuation">,</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined 42</span></code></pre></div><p>По соглашению (большей частью из C-языка прогаммирования), для получения только самого значения <code class="language-text">undefined</code> вместо использования <code class="language-text">void</code>, вы можете использовать <code class="language-text">void 0</code> (хотя и понятно что даже <code class="language-text">void true</code> или любое другое <code class="language-text">void</code> выражение выполнит то же самое). На практике нет никакой разницы между <code class="language-text">void 0</code>, <code class="language-text">void 1</code>, и <code class="language-text">undefined</code>.</p><p>Но, оператор <code class="language-text">void</code> может быть полезен в некоторых других обстоятельствах, например, если нужно быть уверенным, что выражение не вернет никакого результата (даже если оно имеет побочный эффект).</p><p>Например:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// примечание: `APP.ready` поддерживается нашим приложением</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token constant">APP</span><span class="token punctuation">.</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// попробуйте еще раз позже</span>
		<span class="token keyword">return</span> <span class="token keyword">void</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span> doSomething<span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">var</span> result<span class="token punctuation">;</span>

	<span class="token comment">// делаем что - нибудь другое</span>
	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// есть возможность выполнить задачу прямо сейчас?</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// выполняем следующие задания немедленно right away</span>
<span class="token punctuation">}</span></code></pre></div><p>Здесь, функция <code class="language-text">setTimeout(..)</code> возвращает числовое значение (уникальный идентификатор интервала таймера, если вы захотите его отменить), но нам нужно применить оператор <code class="language-text">void</code> чтобы значение, которое вернет функция не было  ложно-положительным  с инструкцией <code class="language-text">if</code>.</p><p>Многие разработчики  предпочитают выполнять действия по отдельности, что в результате работает так же, но не требует применения оператора <code class="language-text">void</code>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token constant">APP</span><span class="token punctuation">.</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// попробуйте еще раз позже</span>
	<span class="token function">setTimeout</span><span class="token punctuation">(</span> doSomething<span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div><p>Итак, если есть место где существует значение (как результат выражения) , и вы находите полезным получить вместо него <code class="language-text">undefined</code>, используйте оператор <code class="language-text">void</code>. Возможно это не должно часто встречаться в ваших программах, но в редких случах, когда это понадобится, это может быть довольно полезным.</p><h3>Специальные числа</h3><p>Тип <code class="language-text">number</code> включает в себя несколько специальных значений. Рассмотрим каждое более подробно.</p><h4>НЕ Число, Число</h4><p>Любая математическая операция которую выполняют с операндами не являющимися числами <code class="language-text">number</code> (или значениями которые могут быть интерпритированы как числа <code class="language-text">number</code>в десятчиной или шестнадцатиричной форме) приведет к ошибке при попытке получить значение чилового типа <code class="language-text">number</code>, в этом случае вы получите значение <code class="language-text">NaN</code>.</p><p><code class="language-text">NaN</code> буквально означает &quot;not a <code class="language-text">number</code> (&quot;НЕ число&quot;), хотя это название/описание довольно скудное и обманчивое, как мы скоро увидим. Было бы правильнее думать о  <code class="language-text">NaN</code> как о &quot;неправильном числе,&quot; &quot;ошибочном числе,&quot; или даже &quot;плохом числе,&quot; чем думать о нем как о  &quot;НЕ числе.&quot;</p><p>Например:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>		<span class="token comment">// NaN</span>

<span class="token keyword">typeof</span> a <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span><span class="token punctuation">;</span>	<span class="token comment">// true</span></code></pre></div><p>Другими словами: &quot;Типом НЕ-числа явдяется число &#x27;number&#x27;!&quot; Ура запутывающим именам и семантике.</p><p><code class="language-text">NaN</code> навроде &quot;сторожевого значения&quot; (другими словами нормальное значение, которое несет специальный смысл) которое определяет сбой при проведении операции назначения числа <code class="language-text">number</code>. Эта ошибка, по сути означает следующее: &quot;Я попробовал выполнить математическую операция и произошла ошибка, поэтому, вместо результата, здесь ошибочное число <code class="language-text">number</code>.&quot;</p><p>Итак, если у вас есть значение в какой-нибудь переменной, и вы хотите проверить, не является ли оно ошибочным числом <code class="language-text">NaN</code>, вы должно быть думаете что можно просто его сравнить пямо с <code class="language-text">NaN</code>, как с любым другим значением, например <code class="language-text">null</code> или <code class="language-text">undefined</code>. Неа.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>

a <span class="token operator">==</span> <span class="token number">NaN</span><span class="token punctuation">;</span>	<span class="token comment">// false</span>
a <span class="token operator">===</span> <span class="token number">NaN</span><span class="token punctuation">;</span>	<span class="token comment">// false</span></code></pre></div><p><code class="language-text">NaN</code> очень особенное значение и оно никогда не будет равно другому значению <code class="language-text">NaN</code> (т.е., оно не равно самому себе). Фактически, это всего лишь значение, которое не рефлексивно (без возможности идентификации <code class="language-text">x === x</code>). Итак, <code class="language-text">NaN !== NaN</code>. Немного странно, да?</p><p>Так как мы <em>можем</em> его проверить, если нельзя сравнить с <code class="language-text">NaN</code> (т.к. сравнение не сработает)?</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>

<span class="token function">isNaN</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></div><p>Достаточно просто, верно? мы использовали встроенную глобальную функцию, которая называется <code class="language-text">isNaN(..)</code> и она сообщила нам является значение <code class="language-text">NaN</code> или нет. Проблема решена!</p><p>Не так быстро.</p><p>У функции <code class="language-text">isNaN(..)</code> есть большой недостаток. Он появляется при попытках воспринимать значение <code class="language-text">NaN</code> (&quot;НЕ-Число&quot;) слишком буквально -- вот, вкратце, как это работает: &quot;проверяем то, что нам передали -- либо это не является числом <code class="language-text">number</code>, либо -- это число <code class="language-text">number</code>.&quot; Но это не совсем правильно.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>

a<span class="token punctuation">;</span> <span class="token comment">// NaN</span>
b<span class="token punctuation">;</span> <span class="token comment">// &quot;foo&quot;</span>

window<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
window<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true -- упс!</span></code></pre></div><p>Понятно, <code class="language-text">&quot;foo&quot;</code> буквально <em>НЕ-Число</em>, но и определенно не яляется значением <code class="language-text">NaN</code>! Этот баг был в JS с самого начала (более 19 лет <em>упс</em>).</p><p>В ES6, наконец была представлена функция: <code class="language-text">Number.isNaN(..)</code>. Простым полифиллом, чтобы вы могли проверить на значение <code class="language-text">NaN</code> <em>прямо сейчас</em>, даже в браузерах не поддерживающих-ES6, будет:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Number<span class="token punctuation">.</span>isNaN<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Number<span class="token punctuation">.</span><span class="token function-variable function">isNaN</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span>
			<span class="token keyword">typeof</span> n <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span> <span class="token operator">&amp;&amp;</span>
			window<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span> n <span class="token punctuation">)</span>
		<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>

Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false -- фуух!</span></code></pre></div><p>Вообще,  мы можем реализовать полифилл <code class="language-text">Number.isNaN(..)</code> даже проще, если воспользоваться специфической особенностью <code class="language-text">NaN</code>, которое не равно самому себе. <code class="language-text">NaN</code> <em>единственное</em> для котрого это справедливо; любое другое значение всегда <strong>равно самому себе</strong>.</p><p>Итак:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Number<span class="token punctuation">.</span>isNaN<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Number<span class="token punctuation">.</span><span class="token function-variable function">isNaN</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> n <span class="token operator">!==</span> n<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div><p>Странно, правда? Но это работает!</p><p><code class="language-text">NaN</code>могут появляться во многих действующих JS программах, намеренно или случайно. Это действительно хорошая идея проводить надежную проверку, например <code class="language-text">Number.isNaN(..)</code> если это поддерживается (или полифилл), чтобы распознать их должным образом.</p><p>Если вы все еще используете <code class="language-text">isNaN(..)</code> в своей программе, плохая новость: в вашей программе <em>есть баг</em>, даже если вы с ним еще не столкнулись!</p><h4>Бесконечности</h4><p>Разработчик пришедшие из традиционных компилируемых языков вроде C, возможно, привыкли видеть ошибку компилирования ли выполнения, например &quot;деление на ноль,&quot; для подобных операций:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre></div><p>Как бы там ни было, в JS, эта операция четко определена, и ее результатом будет являться -- бесконечность <code class="language-text">Infinity</code> (ну или <code class="language-text">Number.POSITIVE_INFINITY</code>). Как и ожидается:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// Infinity</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// -Infinity</span></code></pre></div><p>Как вы видите, <code class="language-text">-Infinity</code> (или <code class="language-text">Number.NEGATIVE_INFINITY</code>) получается при делении-на-ноль где один из операторов (но не оба!) является отрицательным.</p><p>JS использует вещественное представление чисел (IEEE 754 числа с плавающей точкой, о котором было рассказано ранее), вразрез с чистой математикой, похоже что <em>есть</em> возможность переполнения при выполнении таких операций как сложение или вычитание, и в этом случае результатом будет <code class="language-text">Infinity</code> или <code class="language-text">-Infinity</code>.</p><p>Например:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>	<span class="token comment">// 1.7976931348623157e+308</span>
a <span class="token operator">+</span> a<span class="token punctuation">;</span>						<span class="token comment">// Infinity</span>
a <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">970</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// Infinity</span>
a <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">969</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 1.7976931348623157e+308</span></code></pre></div><p>Согласно спецификации, если, в результате операции вроде сложения, получается число, превышающее максимальное число, которое может быть представлено, функция IEEE 754 &quot;округления-до-ближайшего&quot; определит, каким должен быть результат. Итак, если проще, <code class="language-text">Number.MAX_VALUE + Math.pow( 2, 969 )</code> ближе к <code class="language-text">Number.MAX_VALUE</code> чем к бесконечности <code class="language-text">Infinity</code>, так что его &quot;округляем вниз,&quot; тогда как <code class="language-text">Number.MAX_VALUE + Math.pow( 2, 970 )</code> ближе к бесконечности <code class="language-text">Infinity</code>, поэтому его &quot;округляем вверх&quot;.</p><p>Если слишком много об этом думать, то у вас так скоро голова заболит. Не нужно. Серьезно, перестаньте!</p><p>Если однажды вы перешагнете одну из <em>бесконечностей</em>, в любом случае, назад пути уже не будет. Другими словами, в почти литературной форме, вы можете прийти из действительности в бесконечность, но не из бесконечности в действительность.</p><p>Это фактически философский вопрос: &quot;Что если бесконечность разделить на бесконечность&quot;. Наш наивный мозг скажет что-нибудь вроде &quot;1&quot;, или, может, &quot;бесконечность.&quot; Но ни то, ни другое, не будет верным. И в математике, и в JavaScript, операция <code class="language-text">Infinity / Infinity</code> не определена. В JS, результатом будет <code class="language-text">NaN</code>.</p><p>Но, что если любое вещественное положительное число <code class="language-text">number</code>, разделить на бесконечность <code class="language-text">Infinity</code>? Это легко! <code class="language-text">0</code>. А что если вещественное отрицательное число <code class="language-text">number</code>, разделить на бесконечность <code class="language-text">Infinity</code>? Об этом в следующей серии, продолжайте читать!</p><h4>Нули</h4><p>Это может смутить математически-думающего читателя, но в JavaScript есть два значения <code class="language-text">0</code> нормальный ноль (также известных как положительный ноль <code class="language-text">+0</code>) <em>и</em> отрицательный ноль <code class="language-text">-0</code>. Прежде чем объяснять почему существует <code class="language-text">-0</code> , мы должны посмотреть как это работает в JS, потому что это может сбить с толку.</p><p>Кроме того что значение <code class="language-text">-0</code> может быть буквально присвоено, отрицательный ноль может быть результатом математических операций. Например:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">/</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// -0</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// -0</span></code></pre></div><p>Отрицательный ноль не может быть получен в результате сложения или вычитания.</p><p>Отрицательный ноль при выводе в консоль разработчика обычно покажет <code class="language-text">-0</code>, хотя до недавнего времени это не было общепринятым, вы можете узнать что некоторые старые браузеры до сих пор выводят <code class="language-text">0</code>.</p><p>Как бы там ни было, при попытке преобразования отрицательного нуля в строку, всегда будет выведено <code class="language-text">&quot;0&quot;</code>, согласно спецификации.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">/</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>

<span class="token comment">// (некоторые браузеры) выводят в консоль правильное значение</span>
a<span class="token punctuation">;</span>							<span class="token comment">// -0</span>

<span class="token comment">// но спецификация лжет вам на каждом шагу!</span>
a<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// &quot;0&quot;</span>
a <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>						<span class="token comment">// &quot;0&quot;</span>
<span class="token function">String</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// &quot;0&quot;</span>

<span class="token comment">// странно, даже JSON введен в заблуждение</span>
<span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// &quot;0&quot;</span></code></pre></div><p>Интересно,что обратная операция (преобразование из строки <code class="language-text">string</code> в число <code class="language-text">number</code>) не врет:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token operator">+</span><span class="token string">&quot;-0&quot;</span><span class="token punctuation">;</span>				<span class="token comment">// -0</span>
<span class="token function">Number</span><span class="token punctuation">(</span> <span class="token string">&quot;-0&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// -0</span>
<span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span> <span class="token string">&quot;-0&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// -0</span></code></pre></div><p><strong>Предупреждение:</strong> Поведение <code class="language-text">JSON.stringify( -0 )</code> по отношению к <code class="language-text">&quot;0&quot;</code> странное лишь частично, если вы заметите то обратная операция: <code class="language-text">JSON.parse( &quot;-0&quot; )</code> выведет <code class="language-text">-0</code> как вы и ожидаете.</p><p>В дополнение к тому что преобразование в строку скрывает реальное значение отрицательного нуля, операторы сравнения также (намеренно) настроены <em>лгать</em>.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">/</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>

a <span class="token operator">==</span> b<span class="token punctuation">;</span>		<span class="token comment">// true</span>
<span class="token operator">-</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// true</span>

a <span class="token operator">===</span> b<span class="token punctuation">;</span>	<span class="token comment">// true</span>
<span class="token operator">-</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// true</span>

<span class="token number">0</span> <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">;</span>		<span class="token comment">// false</span>
a <span class="token operator">&gt;</span> b<span class="token punctuation">;</span>		<span class="token comment">// false</span></code></pre></div><p>Очевидно, если вы хотите различать <code class="language-text">-0</code> от <code class="language-text">0</code> в вашем коде, вы не можете просто полагаться на то,что выведет консоль разработчика, так что придется поступить немного хитрее:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isNegZero</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	n <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span> n <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> n <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">isNegZero</span><span class="token punctuation">(</span> <span class="token operator">-</span><span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// true</span>
<span class="token function">isNegZero</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token operator">/</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// true</span>
<span class="token function">isNegZero</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// false</span></code></pre></div><p>Итак, зачем нам нужен отрицательный ноль, вместо обычного значения?</p><p>Есть определенные случаи где разработчики используют величину значения для определения одних данных (например скорость перемещения анимации в кадре) а знак этого числа <code class="language-text">number</code> для представления других данных (например направление перемещения).</p><p>В этих случаях, как в примере выше, если переменная достигнет нуля и потеряет знак, тогда, вы потеряете информацию о том, откуда она пришла, до того как достигла нулевого значения. Сохранение знака нуля предупреждает потерю этой информации.</p><h3>Специальное равенство</h3><p>Как мы увидели выше, значения <code class="language-text">NaN</code> и <code class="language-text">-0</code> ведут себя по--особенному при попытке проверки на равенство. <code class="language-text">NaN</code> никогда не равно самому себе, так что вы должны использовать метод ES6 <code class="language-text">Number.isNaN(..)</code> (или полифилл). Аналогично, <code class="language-text">-0</code> обманывает и притворяется (даже при использовании <code class="language-text">===</code> строгого равенства -- подробнее в Главе 4) обычным положительным <code class="language-text">0</code>, так что приходится использовать что-то вроде хаков типа <code class="language-text">isNegZero(..)</code> как предлогалось выше.</p><p>Для ES6, есть новый метод для проверки двух значений на абсолютное равенство, без всех этих исключений. Он называется <code class="language-text">Object.is(..)</code>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token operator">*</span> <span class="token number">0</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> <span class="token number">NaN</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// true</span>
Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span> b<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// true</span>

Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span> b<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// false</span></code></pre></div><p>Есть достаточно простой полифилл для <code class="language-text">Object.is(..)</code> если ES6 не поддерживается:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Object<span class="token punctuation">.</span>is<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Object<span class="token punctuation">.</span><span class="token function-variable function">is</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v1<span class="token punctuation">,</span> v2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// проверка на `-0`</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>v1 <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> v2 <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">/</span> v1 <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">/</span> v2<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// проверка на `NaN`</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>v1 <span class="token operator">!==</span> v1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> v2 <span class="token operator">!==</span> v2<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// любые другие значения</span>
		<span class="token keyword">return</span> v1 <span class="token operator">===</span> v2<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div><p><code class="language-text">Object.is(..)</code>, возможно, не должен быть использован в случаях, когда известно что <code class="language-text">==</code> или <code class="language-text">===</code> являются <em>безопасными</em> (подробнее в Главе 4 &quot;Преобразование&quot;), как операторы, они, вероятно, более эффективны и просты в применении. <code class="language-text">Object.is(..)</code> по большей части применяется в специальных случаях проверки на равенство.</p><h2>Значение против Ссылки</h2><p>Какт во многих других языках, значения могут быть присвоены/переданы либо с помощью копирования-по-значению,либо с помощью копирования-по-ссылке oв зависимости от синтаксиса, который вы используете.</p><p>Например, в C++ если вы хотите передать число <code class="language-text">number</code> переменной в функции и иметь обновленное значение переменной, вы можете объявить параметр функции например <code class="language-text">int&amp; myNum</code>, и когда вы передадите ему переменную например <code class="language-text">x</code>, <code class="language-text">myNum</code> будет <strong>ссылаться на <code class="language-text">x</code></strong>; ссылки -- это как особые формы указателей, когда вы получаете указатель на другую переменную (как <em>алиас (псевдоним)</em>). Если вы не объявляете ссылочный параметр, переданное значение  <em>всегда</em> будет скопировано, Даэе если это сложный объект.</p><p>В JavaScript, нет указателей, и ссылки работают немного по-другому. вы не можете получить ссылку от одной JS переменной на другую. Это просто невозможно.</p><p>ССылки в JS указывают на (общее) <strong>значение</strong>, так если у вас есть 10 разных ссылок, они всегда будут разными ссылками на одно общее значение; <strong>ни одна из этих ссылок/указателей tне будет указывать друг на друга.</strong></p><p>Более того, в JavaScript, нет никахих синтаксических подсказок которые контролируют как будет происходить присовение/передача по значению или по ссылке. Вместо этого, <em>тип</em> значения <em>полностью</em> контролирует будет ли это значение присвоено с помощью копирования-по-значению,либо с помощью копирования-по-ссылке.</p><p>Давайте продемонстрируем:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// `b` всегда копирует значение из `a`</span>
b<span class="token operator">++</span><span class="token punctuation">;</span>
a<span class="token punctuation">;</span> <span class="token comment">// 2</span>
b<span class="token punctuation">;</span> <span class="token comment">// 3</span>

<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> d <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// `d` это ссылка на общее значение `[1,2,3]`</span>
d<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">;</span> <span class="token comment">// [1,2,3,4]</span>
d<span class="token punctuation">;</span> <span class="token comment">// [1,2,3,4]</span></code></pre></div><p>Простые значения (примитивы) <em>всегда</em> назаначаются/передаются копированием-по-значению: <code class="language-text">null</code>, <code class="language-text">undefined</code>, <code class="language-text">string</code>, <code class="language-text">number</code>, <code class="language-text">boolean</code>,и ES6 <code class="language-text">symbol</code>.</p><p>Сложные значения -- объекты <code class="language-text">object</code> (включая массивы <code class="language-text">array</code>, и все объекты-обертки -- подробнее в Главе 3) и функции <code class="language-text">function</code> -- <em>всегда</em> всегда делают копию по ссылке при назначении или передаче.</p><p>В примере выше, т.к. <code class="language-text">2</code> это примитив, <code class="language-text">a</code> содержит начальную копию этого значения, а переменной <code class="language-text">b</code> присвоена другая <em>копия</em> значения. При изменении <code class="language-text">b</code>, вы никоим образом не меняете значение в переменной <code class="language-text">a</code>.</p><p>Но <strong>оба<code class="language-text">c</code> и <code class="language-text">d</code></strong> отдельные ссылки на одно общее значение <code class="language-text">[1,2,3]</code>, которое является сложным значением. Важно понимать что никто из переменных: ни <code class="language-text">c</code> ни  <code class="language-text">d</code> не &quot;обладает&quot; значением <code class="language-text">[1,2,3]</code> в большей степени -- они оба всего лишь равноправные ссылки на значение. Таким образом, когда мы используем любую ссылку для изменения (<code class="language-text">.push(4)</code>) актуального общего значения <code class="language-text">array</code> самого по себе, это влияет только на это общее значение, и обе ссылки будут указываьб на новое измененное значение <code class="language-text">[1,2,3,4]</code>.</p><p>Раз уж ссылки указывают на сами значения, а не на переменные, вы не можете использовать одну ссылку, чтобы изменить место, куда будет указывать другая ссылка:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
a<span class="token punctuation">;</span> <span class="token comment">// [1,2,3]</span>
b<span class="token punctuation">;</span> <span class="token comment">// [1,2,3]</span>

<span class="token comment">// позже</span>
b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
a<span class="token punctuation">;</span> <span class="token comment">// [1,2,3]</span>
b<span class="token punctuation">;</span> <span class="token comment">// [4,5,6]</span></code></pre></div><p>Когда мы делаем присвоение <code class="language-text">b = [4,5,6]</code>, мы не делаем абсолютно ничего,что могло бы повлиять на то, <em>куда</em> <code class="language-text">a</code> все еще ссылается (<code class="language-text">[1,2,3]</code>). Чтобы это выполнить, <code class="language-text">b</code>  должно указывать на <code class="language-text">a</code> вместо того,чтобы ссылаться на массив <code class="language-text">array</code> -- но такой возможности в JS нет!</p><p>Самым распространненым случаем при котором может возникнуть путаница, является использование параметров функции:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	x<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	x<span class="token punctuation">;</span> <span class="token comment">// [1,2,3,4]</span>

	<span class="token comment">// позже</span>
	x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	x<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token number">7</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	x<span class="token punctuation">;</span> <span class="token comment">// [4,5,6,7]</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token function">foo</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>

a<span class="token punctuation">;</span> <span class="token comment">// [1,2,3,4]  а не  [4,5,6,7]</span></code></pre></div><p>Когда мы передаем в аргументе переменную <code class="language-text">a</code>, функция принимает копию <code class="language-text">a</code> по ссылке для <code class="language-text">x</code>. <code class="language-text">x</code> и <code class="language-text">a</code> разные ссылки на одно общее значение <code class="language-text">[1,2,3]</code>. Теперь, внутри функции, мы можем использовать ссылку для изменения самого значения (<code class="language-text">push(4)</code>). Но, когда мы делаем присвоение <code class="language-text">x = [4,5,6]</code>, мы никак не влияем на то значение, на которое изначально указывала переменная <code class="language-text">a</code> -- значит, она все еще указывает на (теперь измененное) значение <code class="language-text">[1,2,3,4]</code>.</p><p>Нельзя с помощью ссылки <code class="language-text">x</code> изменить место, куда ссылается <code class="language-text">a</code>. Мы можем лишь изменить содержимое общего значения, на которое указывют <code class="language-text">a</code> и <code class="language-text">x</code>.</p><p>Чтобы добиться изменения содержимого переменной <code class="language-text">a</code> на значение <code class="language-text">[4,5,6,7]</code>, вы не можете создать и назначить новый массив <code class="language-text">array</code> -- вы должны изменить существующее значение массива <code class="language-text">array</code>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	x<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	x<span class="token punctuation">;</span> <span class="token comment">// [1,2,3,4]</span>

	<span class="token comment">// позже</span>
	x<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// обнуляем массив по месту</span>
	x<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	x<span class="token punctuation">;</span> <span class="token comment">// [4,5,6,7]</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token function">foo</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>

a<span class="token punctuation">;</span> <span class="token comment">// [4,5,6,7]  а не  [1,2,3,4]</span></code></pre></div><p>Как вы можете видеть, <code class="language-text">x.length = 0</code> и <code class="language-text">x.push(4,5,6,7)</code> не создавали но массив <code class="language-text">array</code>, а изменяли существующий общий массив <code class="language-text">array</code>. Таким образом, конечно, <code class="language-text">a</code> ссылается на новое значение <code class="language-text">[4,5,6,7]</code>.</p><p>Помните: вы не можете напрямую управлять/переопределять тип копирования: по-значению или по-ссылке -- эти правила полностью контролируются типом основного значения.</p><p>Чтобы эффективно передать сложное значение (например массив<code class="language-text">array</code>) с помощью копирования по-значению, вам понадобится вручную создать его копию, так чтобы переданная ссылка больше не указывала на оригинал. Например:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token function">foo</span><span class="token punctuation">(</span> a<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div><p><code class="language-text">slice(..)</code> без параметров по умолчанию делает полностью новую (поверхностую) копию массива <code class="language-text">array</code>. Таким образом, мы передаем ссылку только на скопированный массив <code class="language-text">array</code>, а значит <code class="language-text">foo(..)</code> не может повлиять на содержимое <code class="language-text">a</code>.</p><p>Чтобы выполнить обратное действие -- передать примитивное значение таким способом, что его изменения будут, навроде как ссылка -- вам понадобится обернуть значение в другое сложное значение (<code class="language-text">object</code>, <code class="language-text">array</code>, и т.п.), которое <em>может</em> быть передано копированием по-ссылке:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">wrapper</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	wrapper<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
	a<span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">foo</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span>

obj<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 42</span></code></pre></div><p>Здесь, <code class="language-text">obj</code> действует как обертка для примитивного значения в свойстве <code class="language-text">a</code>. когда мы передаем <code class="language-text">foo(..)</code>, копия объекта <code class="language-text">obj</code> передана по ссылке и назначена параметру <code class="language-text">wrapper</code>. Теперь мы можем использовать ссылку <code class="language-text">wrapper</code> для доступа к общему объекту, и обновить его свойство. После выполнения функции, при запросе <code class="language-text">obj.a</code> будет выведено обновленое значение <code class="language-text">42</code>.</p><p>Если вы захотите передать ссылку на примитивное значение например <code class="language-text">2</code>, вы можете просто обернуть его в объект-обертку <code class="language-text">Number</code> (подробнее в Главе 3).</p><p>Это <em>является</em> настоящим копированием по-ссылке для объекта <code class="language-text">Number</code>, который <em>будет</em> передан функции, но, к несчастью, получение ссылки на общий объект не дает права на изменение общего примитивного значения, как ожидалось:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	x<span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// эквивалентно `Object(a)`</span>

<span class="token function">foo</span><span class="token punctuation">(</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2, не 3</span></code></pre></div><p>Проблема в том, что лежащее в основе примитивное значение <em>неизменно</em> (то же самое справедливо для <code class="language-text">String</code> и <code class="language-text">Boolean</code>). Если объект <code class="language-text">Number</code> содержит примитивное значение <code class="language-text">2</code>, это означает, что объект <code class="language-text">Number</code> не может быть изменен для хранения другого значения; вы можете лишь создать новый объект <code class="language-text">Number</code> с другим значением.</p><p>Когда <code class="language-text">x</code> использовано в выражении <code class="language-text">x + 1</code>, лежащее в основе примитивное значение <code class="language-text">2</code> распаковано (извлечено) из объекта <code class="language-text">Number</code> автоматически, значит строка <code class="language-text">x = x + 1</code> очень незаметно меняет <code class="language-text">x</code> и вместо ссылки на общий объект <code class="language-text">Number</code>, переменная <code class="language-text">x</code> просто содержит примитивное значение <code class="language-text">3</code> являющееся результатом математического действия <code class="language-text">2 + 1</code>. Таким образом, <code class="language-text">b</code> снаружи все еще ссылается на оригинальный неизмененный/неизменный объект <code class="language-text">Number</code> содержащий значение <code class="language-text">2</code>.</p><p>Вы <em>можете</em> добавить свойство поверх объекта <code class="language-text">Number</code> (не изменяя его примитивного значения), так вы сможете обменимваться информацией косвенно через дополнительные свойства.</p><p>В любом случае, это не является общепринятым; и, возможно, большинство разработчиков не считают это хорошей практикой.</p><p>Вместо использования объекта-обертки <code class="language-text">Number</code> таким способом, возможно, гораздо удобнее использовать обычный, созданный вручную, объект (<code class="language-text">obj</code>), о котором говорилось в примере ранее. Никто не говорит, что нет разумного использования объекта-обертки <code class="language-text">Number</code> -- просто возможно предпочтительнее будет использовать примитивное значение в большинстве случаев.</p><p>Ссылки достаточно мощные, но иногда они есть там где вам нужно, а иногда они нужны вам там, где их нет. Единственное влияние которое у вас есть при выборе типа копирования по-ссылке или по-значению это выбор типа самого значения, так что вы должны косвенно влиять на поведение присвоения/передачи путем выбора типа значений.</p><h2>Обзор</h2><p>В JavaScript, массивы <code class="language-text">array</code> -- простые коллекции значений любого типа с пронумерованными ячейками. Строки <code class="language-text">string</code> что-то &quot;подобное массивам <code class="language-text">array</code>&quot;, но у них есть различия в поведении и нужно быть осторожными при использовании строк как массивов <code class="language-text">array</code>. Числа в JavaScript включают в себя как &quot;целые&quot; значения так и значения с плавющей точкой.</p><p>Среди примитивнх значений есть некоторые специальные значения.</p><p>Тип <code class="language-text">null</code> имеет только одно значение: <code class="language-text">null</code>, также как и тип <code class="language-text">undefined</code> имеет только одно значение -- <code class="language-text">undefined</code>. <code class="language-text">undefined</code> -- изначальное стандартное значение в любой переменной или свойстве, если никакое другое значение не представлено. Оператор <code class="language-text">void</code> позволяет вам получить значение <code class="language-text">undefined</code> от любого другого значения.</p><p>Числа <code class="language-text">number</code> включают в себя несколько специальных значений, например <code class="language-text">NaN</code> (по идее &quot;Не-Число&quot;, но на самом деле более предпочтительно &quot;неправильное число&quot;); бесконечности <code class="language-text">+Infinity</code> и <code class="language-text">-Infinity</code>; и <code class="language-text">-0</code>.</p><p>Простые примитивные изначения (строки <code class="language-text">string</code>, числа <code class="language-text">number</code>, и т.п.) назначаются/передаются копированием по-значению, но сложные значения (объекты <code class="language-text">object</code>, и т.п.) назначаются/передаются копированием по-ссылке. Ссылки в JS не такие как ссылки/указатели в других языках -- они никогда не указывают на другие переменные/ссылки, только на сами значения.</p></article></div></main><footer>© <!-- -->2020<!-- -->, Built with<!-- --> <a href="https://www.gatsbyjs.org">Gatsby</a></footer></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/pages/posts/you-dont-know-JS-types/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-3cab7f4d358d3b42dcb7.js"],"component---src-templates-blog-post-js":["/component---src-templates-blog-post-js-4b73db3022adcfffa7bc.js"],"component---src-templates-tags-js":["/component---src-templates-tags-js-a8c25651b782acf8179d.js"],"component---src-pages-404-js":["/component---src-pages-404-js-eff5c949e344b95f6dc6.js"],"component---src-pages-index-js":["/component---src-pages-index-js-b2cc0098d2e8c4e42cad.js"],"component---src-pages-tags-js":["/component---src-pages-tags-js-f12560f4247d60c91d1f.js"],"component---src-pages-posts-4-ways-working-with-react-state-md":["/component---src-pages-posts-4-ways-working-with-react-state-md-a587d494fb8ebd97fba9.js"],"component---src-pages-posts-redux-routing-md":["/component---src-pages-posts-redux-routing-md-c313490f4f86c3afeed9.js"],"component---src-pages-posts-typescript-with-babel-md":["/component---src-pages-posts-typescript-with-babel-md-be532848233def60237f.js"],"component---src-pages-posts-understanding-passport-js-md":["/component---src-pages-posts-understanding-passport-js-md-32abea9f08c8d1cb6954.js"],"component---src-pages-posts-ydkjs-scope-closures-md":["/component---src-pages-posts-ydkjs-scope-closures-md-8195148a1a93c38b241c.js"],"component---src-pages-posts-you-dont-know-js-types-md":["/component---src-pages-posts-you-dont-know-js-types-md-d0ccc5d50adda324bc5e.js"]};/*]]>*/</script><script src="/dev-docs/component---src-templates-blog-post-js-4b73db3022adcfffa7bc.js" async=""></script><script src="/dev-docs/styles-3251c89baff59e4ed99c.js" async=""></script><script src="/dev-docs/app-3cab7f4d358d3b42dcb7.js" async=""></script><script src="/dev-docs/commons-219ea28c1c39fae67d6f.js" async=""></script><script src="/dev-docs/webpack-runtime-3f59d165217ef71e6555.js" async=""></script></body></html>