---
title: >-
  Создаем крутые фигуры с помощью Clip-Path и разбиваем привычную боксовую
  модель.
description: >-
  Перевод статьи Karen Menezes  Creating Responsive Shapes With Clip-Path And
  Breaking Out Of The Box. Публикуется с разрешения автора…
date: '2018-12-16T21:15:28.978Z'
categories: []
keywords: []
tags: ["css"]
slug: >-
  /@Dimetrio89/%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%B5%D0%BC-%D0%BA%D1%80%D1%83%D1%82%D1%8B%D0%B5-%D1%84%D0%B8%D0%B3%D1%83%D1%80%D1%8B-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-clip-path-%D0%B8-%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D0%B2%D0%B0%D0%B5%D0%BC-%D0%BF%D1%80%D0%B8%D0%B2%D1%8B%D1%87%D0%BD%D1%83%D1%8E-%D0%B1%D0%BE%D0%BA%D1%81%D0%BE%D0%B2%D1%83%D1%8E-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C-6f5d11ac9427
---

Перевод статьи [Karen Menezes](https://blog.karenmenezes.com/) [Creating Responsive Shapes With Clip-Path And Breaking Out Of The Box](https://www.smashingmagazine.com/2015/05/creating-responsive-shapes-with-clip-path/). Публикуется с разрешения автора. Ссылка на оригинальную статью указана выше. С момента написания статьи 11.05.2015 статус спецификации не изменялся.

Свойство CSS `clip-path` — ваш билет к изменению формы монотонных, боксовых разметок традиционно ассоциирующимся с простым, отзывчивым дизайном. Вы начнете мыслить нестандартно, буквально выходить за рамки, и шестиугольники, звезды и восьмиугольники начнут оживать на ваших веб страницах. Однажды попробовав `clip-path`, вы будете постоянно генерировать любые фигуры, просто настраивая несколько значений

Несмотря на то что основным объектом этой статьи является использование `clip-path` для создания многоугольников с помощью CSS, все примеры поддерживают инлайновый SVG, для дополнительной поддержки в Firefox. Создание отзывчивых фигур с помощью SVG — простая задача, если вы хоть раз использовали `CSS clip-path`.

**Clip-Path, в общих чертах**

Вырезать фигуры, свойством `clip-path`, сродни вырезанию фигур (таких как круг или пятиугольник) из прямоугольного куска бумаги. Это свойство находится в спецификации “CSS Masking Module Level 1”. Состояние спецификации, “CSS masking поддерживает два значения для частичного или полного скрытия частей визуальных элементов: маскирование и обрезка”.

Первая часть, т.е. маскирование, использует графический элемент, такие как изображение PNG, CSS градиент или SVG элемент, как маску для скрытия частей другого элемента.

Вторая часть, т.е. `clip-path`, задействует замкнутый контур, который может быть базовой фигурой определенной в CSS или SVG используя тэг clipPath. Область внутри контура отобразится, а все что снаружи будет отсечено.

Примечание: Маскирование выходит за пределы этой статьи, но на CSS-Tricks и HTML5 Rocks можно найти более подробную информацию.  
Ниже простая визуализация работы `clip-path`:

Примечание: примеры из этой статьи, включая указанный выше, будут работать в Firefox а также в WebKit и Blink браузерах, включая Chrome, Safari и Opera.

**Clip-Path это вам не Clip**

Есть такое старое CSS 2.1 свойство `clip` , которое весьма ограничено, главным образом потому, что оно поддерживает только прямоугольную форму. Это свойство устарело, вместо него нужно использовать `clip-path`.

Пример использования устаревшего синтаксиса:

element {  
 clip: rect(30px, 30px, 20px, 20px);  
}

**Поддержка Clip-Path**

В августе 2014, спецификация “CSS Masking Module” была опубликована как “Candidate Recommendation,” это шаг вперед по сравнению с ранним черновиком “Last Call Working Draft”. До того как мы посмотрим на поддержку в браузерах, важно рассмотреть разные способы применения clip-path к элементу, потому что поддержка в браузерах варьируется в зависимости от этих способов.

Есть два способа применения clip-path:

1.  Базовые фигуры CSS из “CSS Shapes Module” предоставляют удобный способ использования clip-path. Доступны следующие варианты фигур: polygon, circle, ellipse и inset; inset для прямоугольных фигур.
2.  С помощью SVG можно, в качестве альтернативы, создать фигуру используя SVG и затем обрезать элемент по этой фигуре используя синтаксис URL. Есть два способа реализации:

*   ссылкой на инлайновый SVG (т.е. SVG разметка будет размещена прямо на странице)
*   ссылкой на внешний SVG документ. В обоих случаях, элемент clipPath внутри SVG используется чтобы обернуть элемент который определяет фигуру обрезки, будь то круг, многоугольник, или другой элемент.

Сравните демо ниже в Firefox и в WebKit или Blink браузере, например Chrome, чтобы почувствовать разницу. Квадратные изображения означают ошибку при поддержке браузером. Примечание: третье изображение не показывается в Safari. Несмотря на широкий дебаггинг, решить проблему не удалось. Я была бы благодарна, если в секции комментов встретилось решение.

Если вы тестировали пример кода выше в разных браузерах, то наверняка заметили, что поддержка клиппирования довольно странная, и на данный момент она основывается на выборе способов которые вы применяете чтобы обрезать элемент:

*   с CSS: Chrome 24+, Safari 7+, Opera 15+, iOS 7.1+, Android 4.4+, Opera Mobile 24+ (Примечание: для поддержки в указанных браузерах необходимо использовать вендорные префиксы -webkit.)
*   с SVG: все браузеры указанные выше и Firefox 3.5+

Свойство clip-path пока не поддерживается Internet Explorer, но находится на рассмотрении как часть “Masking Module.”

Примечание: Есть оговорка насчет поддержки SVG для клиппирования. Современные WebKit и Blink браузеры поддерживают клиппирование с SVG только если SVG — инлайновый (т.е. внутри документа). Ссылки на внешние SVG поддерживаются только в Firefox, что подтверждается в примере кода выше. Проект Chromium знает об этом баге и работает над ним.

Давайте посмотрим преимущества CSS и SVG при использовании clip-path.

Преимущества CSS

*   Легкий для понимания простой синтаксис, по причине относительной простоты базовых CSS фигур.
*   Отзывчивость легко достигается с помощью применения относительных единиц измерения, таких как проценты.

Преимущества SVG

*   Лучшая поддержка в браузерах, включая Firefox
*   Вы можете обрезать сложные фигуры, использовать множество фигур и текст.

Пока CSS предлагает свойство background-clip, которое поддерживает множество вариантов (включая нестандартные способы обрезки текста), ни background-clip ни CSS’ clip-path не достигают того, что можно сделать с помощью SVG обрезки в современных браузерах. Знакомство с clip-path через CSS, тем не менее, не такое пугающее (особенно если вы не знакомы с манипуляциями SVG) и подготовит вас к тонкостям клиппирования с SVG, также как в “CSS Shapes Module,” где содержимое выравнивается по форме элемента.

Примечание: если вам не терпится окунуться во все тонкости SVG, [обзор Sara Soueidan](https://www.sarasoueidan.com/blog/css-svg-clipping/) будет хорошим началом.

Давайте посмотрим на плюсы и минусы clip-path чтобы постепенно улучшить наш дизайн.

Плюсы

*   Браузеры, не поддерживающие свойство clip-path будут его игнорировать. Если вы используете его с осторожностью, пользователи неподдерживаемых браузеров ничего не заподозрят. Таким образом событие клика ограничено фигурой и ее внешними границами. Мы увидим это в примерах кода ниже.
*   Вы можете использовать проценты или любые другие единицы длины такие как px или em, для определения координат с базовыми фигурами CSS. Относительные единицы такие как проценты могут быть использованы для создания отзывчивых фигур, идеальных для адаптивного дизайна.

Минусы

*   Все границы, тени и контуры снаружи области обрезки будут отсечены. Вы можете добавить границу и ожидать что это будет выполнено. Посмотрим на некоторые альтернативы ниже.
*   Спецификация еще не достигла стадии “Recommendation”, так что всегда есть шанс, что синтаксис будет временно изменен.
*   Сообщалось о нескольких багах при использовании clip-path и 3Д трансформаций, переходов и проразчности, они будут рассмотрены в примерах далее. Будьте осторожны и избегайте комбинировая свойств, которые могут спровоцировть эти проблемы.

**Clip-Path с использованием polygon: использование и синтаксис**

Примеры кода ниже сфокусированы на использовании многоугольников в дизайне. Синтаксис для базовых фигур (т.е. прямоугольник, круг и эллипс) достаточно прост, и вы можете сделать с ними достаточно много. Многоугольники, тем не менее, практически открывают дверь к бесконечному числу фигур.

Базовый синтаксис для многоугольника выглядит следующим образом:

.element { clip-path: polygon(x1 y1, x2 y2, x3 y3, …); }

Каждая пара аргументов в списке представляет координаты по осям `x` и `y` вершин многоугольника.

Вот — как это выглядит в реальном мире (не считая текущей поддержки версии с префиксом WebKit):

.element { clip-path: polygon(0 100%, 0 0, 100% 0, 80% 100%); }

Добавим поддержку для Firefox с помощью ссылки на инлайновый SVG:

.element { clip-path: url(“#clip-shape”); }

Вот как выглядит наш селектор с кроссбраузерной поддержкой:

.element {  
    -webkit-clip-path: polygon(0 100%, 0 0, 100% 0, 80% 100%);  
    clip-path: polygon(0 100%, 0 0, 100% 0, 80% 100%);  
    -webkit-clip-path: url(“#clip-shape”); /\* required for    Webkit/Blink browsers if you’re using only inline SVG clipping paths, but not CSS clip-path \*/  
    clip-path: url(“#clip-shape”);  
}

Ниже представлен код инлайнового SVG, который необходимо добавить в разметку.

<svg width=”0" height=”0">  
 <defs>  
 <clipPath id=”clip-shape” clipPathUnits=”objectBoundingBox”>  
 <polygon points=”0 1, 0 0, 1 0, 0.8 1" />  
 </clipPath>  
 </defs>  
</svg>

И окончательный пример кода с многоугольником:

Вы можете создать отзывчивый SVG для обрезки в следующем порядке:

*   Установите width и height для SVG в 0.
*   Назначьте ID для clipPath элемента внутри SVG, на который можно ссылаться в CSS. Вы можете использовать инлайновый или внешний SVG, держа в уме поддержку браузеров, о которой говорилось ранее.
*   Используйте значения координат в процентах назначенные в CSS clip-path. Просто делите их на 100 и уберите единицы измерения SVG.  
    Установите значения атрибута clipPathUnits для objectBoundingBox, таким образом фигура обрезки послужит границами HTML элемента на который она ссылается.

[Dudley Storey](http://demosthenes.info/blog/1007/Combining-CSS-clip-path-and-Shapes-for-New-Layout-Possibilities) может рассказать больше об этом.

Давайте посмотрим на примере как составить координаты для многоугольника.

Итак у нас есть изображение, которое обрезано. Фоновым цветом обозначены габариты оригинального изображения. Ячейки с координатами просто абсолютно спозиционированные дивы, положение которых, соответствует координатам многоугольника в процентах. Вы увидите, что они сохраняют свою позицию, даже даже если вы измените ширину окна браузера (например, до 400px или более).

**Реальные примеры использования Clip-Path**

Примечание: Каждый пример кода в этой статье использует clip-path с CSS но также имеет инлайновый SVG в разметке с классом clip-svg, который просто обнуляет значения высоты и ширины SVG. В качестве альтернативы, вы можете удалить класс и обнулить высоту и ширину прямо в разметке SVG.

_Пример 1: Обрезаем изображение до разных многоугольных фигур_

В данном случае нам понадобится определение многоугольника, это плоская замкнутая фигура состоящая из прямых линий.

Таким образом, фигура не может быть многоугольником если содержит кривые, разомкнута, или состоит менее чем из трех отрезков. Самые часто встречающиеся многоугольники: треугольники, четырехугольники, пятиугольники и шестиугольники. Даже фигура звезды является многоугольником, т.к. границы многоугольника связаны между собой.

Примечание: Изображения в примерах — отзывчивые. Используя решение для отзывчивости изображений img { max-width: 100%; height: auto; } и адаптивные области обрезки для CSS и SVG, мы делаем наши многоугольники пропорционально уменьшающимися и увеличивающимися.

Этот пример является результатом упражнений по назначению координат для многоугольных фигур. В примере добавлены несколько фигур, которые вы можете использовать для своего дизайна. При наведении курсора на каждое изображение, вы увидите соотношение сторон оригинального изображения.

Ничто не сравнится с особенным [Clippy](http://bennettfeely.com/clippy) , GUI инструментом от Bennett Feely для визуализации фигур. Все координаты для всех существующих фигур указаны в процентах, а также есть вариант с настраиваемым многоугольником. Это поворотный момент. Вы можете использовать Clippy для создания фигур обрезки и SVG для них, с целью лучшей поддержки в браузерах.

_Пример 2: Анимация базовых фигур с помощью переходов CSS_

Наведите курсор на фиолетовый шестиугольник. Он трансформируется в восьмиугольник. Тем не менее, переход CSS не сработал.

Причина такого поведения объяснена в статье Sara Soueidan об анимации фигур CSS : “ Число точек конечной фигуры должно соответствовать числу точек начальной фигуры.” Это вполне разумно!

Т.к. шестиугольник имеет шесть пар координат вершин, давайте добавим еще две пары дублирующих координат, чтобы достичь числа координат для восьмиугольника. эти дублирующие пары координат никак не повлияют на шестиугольник.

Так выглядит стандартное объявление шести пар координат для шестиугольника:

clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);

А это объявление шестиугольника с восемью парами координат (первые две вершины продублированы):

clip-path: polygon(50% 0%, 50% 0%, 100% 25%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);

Теперь, при трансформации фигуры, переход будет плавным, как в примере ниже.

Примечание: Для браузеров поддерживающих области обрезки через SVG (а именно Firefox), нам понадобится добавить SMIL анимацию для реализации перехода при наведении. Согласно SMIL спецификации, анимации могут использоваться для изменения контуров и точек фигур SVG, которое невозможно выполнить средствами CSS.

Помните, что некоторые осуждают использование SMIL в Chrome и Chromium при этом фокусируясь на внедрении Web Animations API, которое, к сожалению, пока на стадии раннего черновика.

В примере ниже, вы можете увидеть, что мы анимировали вершины многоугольника между событиями указателя мыши mouseover и mouseout events в течение 0.2 секунд. Обратите внимание на тэг <animate> в SVG разметке.

_Пример 3: Добавляем границы для обрезанного объекта._

Короче, границы, контуры и тени that находящиеся снаружи обрезаемой области будут удалены.

Меня немного опечалил этот факт, и я решила отправить запрос представителям W3C рабочей группы CSS. Тем не менее, в итоге оказалось, что нет способа реализовать это при использовании базовых фигур. Dirk Schulze ответил на мой запрос: “Да, все операции отрисовки,которые принадлежали элементу будут обрезаны. Это включает контуры и границы.”

Посмотрите на пример кода ниже. Наведите курсор на ромб с частичными границами чтобы увидеть оригинальную, полную версию со всеми границами.

Конечно, мы всегда можем использовать CSS хак чтобы получить границу, к чему я в итоге и решила прибегнуть — старый добрый генерируемый контент.

В примере ниже создается копия элемента через псевдо-элемент (content:after) с абсолютным позиционированием. Получается иллюзия границы, позволяя нам использовать интересные эффекты, такие как граница с градиентом во втором восьмиугольнике и добавление тени с помощью CSS фильтра на третьем (не очень симпатично, зато работает). Заметьте, что that CSS фильтры на текущий момент работают только в Firefox и в WebKit и в Blink браузерах.

_Пример 4: Используем CLIP-PATH для создания “бриллиантовой” сетки из ромбов._

Ниже изображение которое мы будем использовать.

![](img/1__cgjmu9C__VdX1ydQ__XCqWNg.jpeg)

А это то, к чему мы стремимся. По наведению на один из трех нижних блоков, вы увидите что фоновый цвет постепенно исчезает и появляется фон.

![](img\1__AQ8O0fH1lnjb__ENCtAODoA.jpeg)

Актуальный размер изображения составляет 600 × 600 пикселей. Значит, давайте начнем с четырех пустых дивов по 300 пикселей каждый и применим к ним одинаковое фоновое изображение. Еще добавим родительский контейнер размером 604 пикселя и разместим изображения с применением свойства \`inline-block\`.

![](img\1__ULTvyvMYFrVwGXaR9e9ZMw.jpeg)

Теперь, изменим значение свойства `background-position` для каждого изображения на `top` , `left`, `right` и `bottom` , соответственно.

Давайте обрежем каждый блок по фигуре ромба.

Мы перекроем абсолютно спозиционированным слоем три нижних изображения, с небольшим текстом.

![](img\1__iNCPS7DGZkyR0RiCfLhGng.jpeg)

Теперь переместим изображения в строки — второе и третье изображение в одну строку, а первое и четвертое изображение в собственные индивидуальные строки.

![](img\1__Ce1Ec6u04cWHIed6mVdkqQ.jpeg)

Наконец, используем отрицательные `margins` чтобы поднять вторую и третью строки, таким образом они будут располагаться как в примере ниже. Мы можем удалить значение ширины родительского контейнера 604 пикселя, и назначить медиа запросы, чтобы блоки ромбов менялись от расположения в колонку на маленьких экранах, до расположения в строку на экранах побольше.

Работая над эти примером, я заметила баг в Chrome с направленным `pointer-events` вне обрезанной области, что является нарушением спецификации: “По умолчанию, `pointer-events` не должно ссылаться на отсеченные (неотображаемые) области фигуры.” Я получила ошибку. Проблема в этом примере решена использованием свойства `pointer-events` со значением `none` для слоя наложения. В качестве альтернативы, вы можете применить такое же значение `clip-path` для слоя наложения. Чтобы решить проблему.

Из-за применения отрицательных отступов, этот пример может выглядеть странно в браузерах, не поддерживающих `clip-path`. Вам нужно использовать что-то типа проверки возможности использования `clip-path` для применения отступов (хотя, я этого не пробовала) или использовать запрос для CSS [@supports](http://twitter.com/supports "Twitter profile for @supports"), хотя последнее я не рекомендую использовать в продакшене.

_Пример 5: Делаем глупую страничку профиля с шестиугольниками._

В результате наша страница должна выглядеть так:

![](img\1__iwBoRGxM__grZrb2sOC6V1A.jpeg)

Начнем с добавления фонового изображения из шестиугольных плиток для `body` (спасибо за изображение Subtle Patterns).

Значения шестиугольника для `clip-path` могут быть получены из примеров ниже или с помощью Clippy tool.

Первый шестиугольник использует фоновое изображение (т.к. мы подмешиваем скучный бордовый в фон используя свойство `background-blend-mode`). Используя полученное содержимое, абсолютно спозиционированный перекрывающий слой обрезается до бордового треугольника, который вы видите внизу. Он исчезает при наведении курсора.

Второй шестиугольник, со словом “work,” просто содержит серый фон, который меняется при наведении.

У третьего шестиугольника есть граница с градиентом, так же как и в одном из примеров с созданием границ с помощью `clip-path`.

Шестиугольники складываются на маленьких экранах и центрируются по вертикали на экранах побольше. Я использовала комбинацию свойства `display` : `table` и хака для абсолютного центрирования — конечно, вы можете использовать `flexbox`, `floats` или что-то еще, что поможет удержать ваш корабль верстки “на плаву”.

Вот итоговый пример кода.

Я обнаружила баг `clip-path` при создании этого примера. Изменение значения свойства `opacity` в сочетании с переходами CSS провоцирует мигание и артефакты на странице. Избегайте этого, если вы используете `clip-path` чтобы улучшить дизайн.

Также есть проблема при использовании `clip-path` и свойства `backface-visibility` если его установить в значение `hidden`. Этот баг указан в баг трекере Chromium и мне удалось его воспроизвести используя основной синтаксис для фигур в Chrome на Linux. Помните об этом если используете `clip-path` фигуру для создания крутого 3D поворота или чего нибудь, что использует 3D трансформации CSS.

Обрезка с помощью SVG без труда побеждает из-за ее гибкости иnи вариаций, но ничто не сравнится с легкостью,с которой элемент может быть обрезан с помощью CSS. Фактически, те же координаты для многоугольника могут быть играючи преобразованы для создания отзывчивого SVG и лучшей поддержки браузерами. С `clip-path`, вы можете кардинально менять вид и поведение страницы, не слишком волнуясь о поддержке браузерами, где она ухудшена. При выборе `clip-path` для улучшения дизайна, следите за статусом спецификации, возможно она продвинется до статуса “Recommendation”.

Ресурсы, Инструменты и Вдохновение

*   [CSS Masking Module Level 1](http://www.w3.org/TR/css-masking-1) W3C лучший источник истины при возникновении сомнений.
*   [Clipping in CSS and SVG: The clip-path Property and \`<clipPath>\` Element](http://sarasoueidan.com/blog/css-svg-clipping) Подробное руководство Sara Soueidan по обрезке фигур. Т.к. по большей части там фокусируются на SVG, эта статья — фантастическое введение, с достаточным количеством информации даже для продвинутых читателей.
*   [clip-path](http://tympanus.net/codrops/css_reference/clip-path) статья Sara Soueidan для Codrops — тщательно проработанное и исчерпывающее руководство разбивает реально сложные модули на то что легко понять и усвоить.
*   [Clipping and Masking in CSS](http://css-tricks.com/clipping-masking-css/) статья Chris Coyier на CSS-Tricks снабженная несколькими полезными примерами, объясняющими как клиппирование так и маскирование.
*   [Clippy](http://bennettfeely.com/clippy) инструмент от Bennett Feely для создания clip-path может генерировать множество предустановленных и кастомных многоугольников, кругов и эллипсов для CSS clip-path. Все значения указаны в процентах, следовательно, это будет полезно при создании адаптивной верстки.
*   [Clip Path Generator CSS Plant](http://cssplant.com/clip-path-generator) предоставляет более исчерпывающий графический интерфейс для применения клиппирования или маскирования элементов. Браузерная поддержка реализована для Firefox, Chrome, Safari и старых iOS. Размеры в пикселях, не в процентах.
*   [Species in Pieces](http://www.species-in-pieces.com/) Захватывающая дух, демонстрация из 30 исчезающих видов была разработана полностью с помощью CSS’ `clip-path`, без помощи `canvas` или `WebGL`. Пока остальные браузеры не подхватятся смотрите ее в WebKit или Blink браузерах.