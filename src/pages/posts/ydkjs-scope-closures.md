---
layout: post
title: Вы не знаете JS. Область видимости и замыкания.
date: "2020-07-24"
tags: ["js"]
---

# Области видимости и замыкания 

Короткие, и надеюсь интересные, конспекты для систематизации знаний по JS после прочтения серии книг You Don't Know JS.

## Разбираемся с областями видимости

![start image](../../images/ydkjs-scope-closures/start.jpeg)
Что такое область видимости?

Основная функция любой программы заключается в возможности сохранять значения в переменных и при необходимости извлекать их. И переменные хранятся в области видимости (`scope`).

В языках программирования, которые компилируются есть три основных этапа при работе с кодом, прежде чем он будет выполнен:

Токенизация. Разбитие кода на кусочки, которые несут значение -токены.

Парсинг. Берем массив токенов и составляем из них абстрактное синтаксическое дерево.(AST — Abstract Syntax Tree)

Генерация кода.Берем AST и преобразуем его в исполняемый код (для работы с памятью и вот это всё)

У JS нет времени объяснять всё это, т.к. до исполнения кода, у JS есть лишь микросекунды на его обработку.

Попробуем понять как работает область видимости.

### Движок (Engine)

![engine image](../images/ydkjs-scope-closures/start.png)

Отвечает за начало и окончание интерпретации кода и выполнение программы.

### Компилятор (Compiler).

![compiler image](../images/ydkjs-scope-closures/compiler.jpeg)

Один из друзей Движка. Делает грязную работу типа парсинга и генерации исполняемого кода.

### Область видимости (Scope).

![scope image](../images/ydkjs-scope-closures/scope.jpeg)

Другой бро Движка: собирает и обслуживает список поиска всех объявленных идентификаторов (переменных)а также следит за соответствием правилам для исполняемого кода.

На простом примере:

```js
var a = 2;
````

Что делает компилятор

Встретив `var a`, компилятор спрашивает у области видимости: может такая переменная уже есть в области. И, если она уже есть, компилятор игнорит объявление переменной и едет дальше. Если же, такой переменной нет, компилятор просит создать новую переменную с именем `a` у области видимости.

Потом компилятор готовит код для движка, чтобы затем выполнить присвоение `a = 2` . 

При этом Движок должен уточнить у области видимости: если переменная есть в текущей области видимости, движок будет использовать именно ее. Если нет — Движок поищет ее где — нибудь еще.

Если Движок ее не найдет, он прекратит поиски и сформирует ошибку.

Движок может производить как левосторонний (LHS — Left Hand Side) так и правосторонний (RHS — Right Hand Side) поиск. 

Поиск распределяется по отношению к оператору присвоения `=` .

```js
console.log( a );// правосторонний поиск
a = 2; //левосторонний поиск
function foo(a) {
    console.log( a ); // 2
}
foo( 2 );//1) RHS при вызове функции foo() 
//2)LHS при передаче аргумента a значения 2 происходит присвоение 
//a = 2;
```

Представим разговор Движка и Области видимости:

Engine: Привет Scope, у меня тут RHS ссылка для `foo`. Слышал про такое?

Scope: Да, конечно. Интерпретатор только что объявил `foo`. Это функция. Вот она.

Engine: Круто, спасибо! OK, выполняю `foo`.

Engine: Слушай область видимости, тут еще LHS ссылка для `a`, слышал о ней?

Scope: Да. Буквально только что интерпретатор объявил ее как параметр для `foo`. Вот она.

Engine: Как всегда кстати)). И снова спасибо. Пришло время присвоить значение 2 переменной a.

Engine: Сорри за беспокойство. Мне нужно посмотреть RHS для `console`. Не слышал?

Scope: Нет проблем, Engine, это то,что я делаю целый день. Да есть объект `console`. Он встроенный. Вот пользуйся.

Engine: Отлично. Поищем — ка `log(..)`. OK, это функция.

Engine: Йоу, Scope. Можешь помочь с RHS ссылкой на a.
Я вроде помню его, просто хотел еще раз уточнить.

Scope: Да ты прав, Engine. Та же переменная, значение не изменилось. Можешь пользоваться.

Engine: Круто, значит передаем значение 2 переменной `a`, а ее затем функции `log(..)`.


Также как функция или блок могут быть вложены в другой блок или функцию, области видимости могут быть вложенными.

```js
function foo(a) {
    console.log( a + b );
}
var b = 2;
foo( 2 ); // 4
```

Engine: “Привет, Scope из функции `foo`, слышал что нибудь про `b`? Только что получил RHS ссылку для него.”

Scope: “Не не слышал. Поищи в другом месте.”

Engine: “Хэй, Scope снаружи функции `foo`, о да ты глобальный `scope`, OK
круто. Слышал что нибудь про `b`? Только что получил RHS ссылку для него.”

Scope: “Да конечно. Вот — пользуйся.”

__Итак, движок будет искать ссылку начиная с текущей области видимости и заканчивая глобальной.__

![finding image](../images/ydkjs-scope-closures/finding.jpeg)

Если же, и в глобальной области ссылка не будет найдена, то, в зависимости от того какую ссылку мы ищем, RHS или LHS, могут быть разные результаты.

Если поиск идет по RHS ссылке, то есть по правой стороне, и переменная не найдена, то мы получим `ReferenceError`.

Если поиск идет по LHS ссылке, то есть по левой стороне и переменная не найдена, то все зависит от того, используем мы `StrictMode` или нет.

Если не используем `StrictMode`, то в глобальной области будет создана переменная с указанным именем и передана движку. 

Если же включен `StrictMode`, то мы также получим `Reference Error`.

Ну, а если поиск по RHS увенчался успехом, но мы пытаемся сделать с результатами поиска что нибудь противоестественное. 

Например, использовать нефункцию как функцию, или ссылаться на свойства, значения которых `null` или `undefined`, то мы получим `TypeError`.

## Лексическая область видимости.

В языках программирования используется два вида областей видимости: лексическая и динамическая. Для JS используется лексическая область видимости.

В приведенном выше примере кода, движок выполнит `console.log()`, а значит будет искать три переменные `a`, `b` и `c` . 

Движок начнет искать с самой глубокой области видимости — области видимости функции `bar()` . 

Поскольку переменной `a` нет в области видимости функции `bar()` , поиск перейдет на ближайшую область видимости — область видимости функции `foo()` . 

То же самое для переменной `b` . 

Ну а `c` будет найдена в области видимости `bar()` . 

Если `a` и `c` будут также объявлены в `bar()`, то при поиске мы не попадем в область функции `foo()` . Поиск всегда останавливается как только найдет первый результат.

__Неважно где, и каким образом функция вызывается, лексическая область видимости всегда определяется там, где функция была объявлена.__

## Функциональная и блочная область видимости

Область видимости состоит из серии “пузырей”, каждый из которых является своего рода контейнером или корзиной,
в которых могут быть объявлены идентификаторы (переменные, функции, вот это всё). 

Эти пузыри вложены друг в друга, и эта вложенность определяется автором приложения. Но что на самом деле может создавать новый пузырь области видимости? Только функция или другие структуры в JS тоже могут это делать?

### Область видимости функций.

Самый распространенный ответ на эти вопросы: __в JS функциональная область видимости.__ 

Итак, каждая функция создает для себя собственный пузырь и нет других структур, создающих свои области видимости. Как мы увидим, это не совсем так.

```js
function foo(a) {
	var b = 2;
	// some code
	function bar() {
		// ...
	}
	// more code
	var c = 3;
}
````

В этом примере кода область видимости `foo(..)` включает в себя идентификаторы `a,b,c` и `bar`. 

Неважно где происходит объявление, переменная или функция принадлежат области видимости в независимости от этого. `bar(..)` имеет собственную область видимости. Ну а глобальная область содержит лишь один идентификатор `foo(..)`. `a, b, c,` и `bar(..)` принадлежат области функции `foo(..)` и вне `foo (..)` обращение к этим идентификаторам вызовет ошибку `ReferenceError`.

В любом случае, все идентификаторы (`a, b, c, foo` и `bar`) доступны внутри `foo(..)`, а также внутри `bar(..)`.

__Функциональная область видимости способствует идее, что переменные принадлежащие функции могут быть использованы
как внутри самой функции, так и во вложенных областях видимости.__


Традиционное представление о функции: вот мы объявляем функцию и дальше пишем внутри нее код. 

Но более мощное и полезное представление: берем любой кусок кода и обворачиваем его в функцию — типа “прячем” код. Зачем прятать функции и переменные? При разработке программ принято пользоваться принципом наименьшего влияния(воздействия). 

Этот принцип говорит о том что при разработке программ таких как API для модулей/объектов нужно выставлять только то, что минимально необходимо, а все остальное “скрывать”.

Этот же принцип распространяется и на выбор области видимости для хранения переменных и функций. Если все переменные и функции будут объявлены в глобальной области видимости, они конечно будут доступны для любой другой вложенной области.
Но при этом нарушится принцип наименьшего влияния.

```js
function doSomething(a) {//Здесь излишним будет внешний доступ к b и doSomethingElse
	b = a + doSomethingElse( a * 2 );
	console.log( b * 3 );
}
function doSomethingElse(a) {
	return a - 1;
}
var b;
doSomething( 2 ); // 15
//Конечный результат и назначение функции сохранены при этом нет доступа к промежуточным переменным и функциям.

function doSomething(a) {
	function doSomethingElse(a) {
		return a - 1;
	}
	var b;
	b = a + doSomethingElse( a * 2 );
	console.log( b * 3 );
}
doSomething( 2 ); // 15

/*Кроме того скрывая переменные и функции  в областях видимости можно избежать конфликтов между двумя
разными идентификаторами с одинаковыми именами. Результатом такого конфликта может стать неожиданная
перезапись значений*/
function foo() {
	function bar(a) {
		i = 3; // изменим `i` внутри цикла при его выполнении
		
		console.log( a + i );
	}
	for (var i=0; i<10; i++) {
		bar( i * 2 ); // и получаем бесконечный цикл!
	}
}
foo();
/*Обертывание кода в функции для создания областей видимости имеет свои недостатки:
1) Нужно объявлять функцию с именем котрое в свою очередь будет являться идентификатором и засорять 
родительскую область видимости.
2)Нужно явно вызвать функции чтобы выполнить код из нее
Было бы здорово если бы функции не нужно было имя и еще неплохо было бы автоматически ее выполнять.
*/
var a = 2;
(function foo(){ /* <-- вместо объявления функции(Function Declaration) 
	используем функциональное выражнение (Function Expression) */
	var a = 3;
	console.log( a ); // 3
})(); 
/*(function foo(){ .. }) - подобное выражение означает что идентификатор foo находится только внутри себя
т.е. на месте .. а не во внешней области видимости
*/
console.log( a ); // 2
/* Анонимные или именнованные?
Есть функциональные выражения переданные другой функции в качестве параметра это называется анонимное
функциональное выражение*/
setTimeout( function(){
	console.log("I waited 1 second!");
}, 1000 );
/*Использование анонимных функций затрудняет отладку
в случае с рекурсией понадобится ссылка на эту функцию
функции с именами делают код более удобно читаемым.*/
setTimeout( function timeoutHandler(){ // <-- У меня есть имя!
	console.log( "I waited 1 second!" );
}, 1000 );
//Итак в примере ниже первая пара скобок создает функциональное выражение
var a = 2;
(function foo(){ /* <-- вместо объявления функции(Function Declaration) 
	используем функциональное выражнение (Function Expression) */
	var a = 3;
	console.log( a ); // 3
})(); // а вторая пара скобок сразу ее вызывает 
//IIFE- immediatly invoked function expression немедленно вызываемое функциональное выражение
/* Также можно использовать (function(){ .. }()) когда пара скобок вызывающих функцию будет находится внутри
внешней пары скобок. Разницы никакой, работать будет точно также. Это вопрос стиля, который ты предпочитаешь
*/
var a = 2;
(function IIFE( global ){//Передаем ссылку на объект window но т.к. мы назвали параметр global
	var a = 3;//мы легко можем отличить глобальные ссылки от локальных
	console.log( a ); // 3
	console.log( global.a ); // 2
})( window );
console.log( a ); // 2
````

### Блочная область видимости.

В большинстве случаев в JS области видимости создают функции. Но переменные необходимо объявлять настолько близко к тому месту, где они будут использоваться, насколько это возможно. 

К сожалению, по умолчанию, блоки `if` или `for` не создают собственных областей видимости. В свою очередь, конструкции `with` или `try/catch` создают собственные области видимости.

```js
var foo = true;
if (foo) {//блочной видимостью будут обладать переменные объявленные с помощью let
	let bar = foo * 2;
	bar = something( bar );
	console.log( bar );
}
console.log( bar ); // ReferenceError
//также объявление с помощью let не поднимается выше
{
console.log( bar ); // ReferenceError!
let bar = 2;
}
//Собираем мусор))
function process(data) {
// работаем с данными
}
var someReallyBigData = { .. };//Реально большие данные
process( someReallyBigData );//Обрабатываем...
//событию не нужен блок с большими данными но JS придется его хранить пока мы не уйдем в область видимости
// функции click
var btn = document.getElementById( "my_button" );
btn.addEventListener( "click", function click(evt){
	console.log("button clicked");
}, /*capturingPhase=*/false );
//Пример с блочной областью
function process(data) {
// работаем с данными
}
// все что объявлено внутри блока будет очищено после выполнения
{
	let someReallyBigData = { .. };
	process( someReallyBigData );
}
var btn = document.getElementById( "my_button" );
btn.addEventListener( "click", function click(evt){
	console.log("button clicked");
}, /*capturingPhase=*/false );
//let в циклах
for (let i=0; i<10; i++) {//let не только связывает loop из заголовка но и перепривязывает его
	console.log( i );//каждую итерацию чтобы быть увереным что мы получили значение в конце предыдущей итерации
}
console.log( i ); // ReferenceError
//const ведет себя аналогично let правда попытка присвоить значение отличное от первоначального вызовет ошибку
````

#### Поднятие переменных.

Это искушение — считать что JS код выполняется строка за строкой по мере выполнения программы сверху вниз. Есть случаи в которых это не так. Движок компилирует код, прежде чем его интерпретировать.

Сначала обрабатываются все объявления: переменных и функций.

Это называется __“поднятием”__.

```js
a = 2;// 2. Присваеваем переменной a значение 2
var a;//1. Объявляем переменную a в глобальной области видимости
console.log( a );//выводим ее значение 2
//другой пример 
console.log( a );//2. выводим ее значение undefined
var a = 2;//1. Объявляем переменную a в глобальной области видимости
//3. Присваеваем переменной a значение 2
//Соответственно функция foo() объявленная после ее вызова будет поднята на первую строку соответствующей области
foo();
function foo() {
	console.log( a ); // undefined
	var a = 2;
}
// И функции и переменные поднимаются наверх но функции первые))
foo(); // 1 выполняем функцию
var foo;//2. Объявляем переменную foo(но т.к. она уже есть объявление игнорится)
function foo() { // 1. Объявляем функцию foo()
	console.log( 1 );
}
foo = function() {
	console.log( 2 );
};
// Пример с многократным объявлением функции указывает на то что  объявления функции игнорится не будут
// Последнее объявление перезапишет предыдущие.
foo(); // 3
function foo() {
	console.log( 1 );
}
var foo = function() {
	console.log( 2 );
};
function foo() {
	console.log( 3 );
}
```

## Замыкания

Просветление. Для тех у кого уже есть опыт с JS, но они не догоняют концепцию замыканий, понять замыкания это как нирвана которой нужно достичь)).
Замыкания везде вокруг тебя в JavaScript нужно просто признать и обнять их. 

Понять замыкания — это то чувство, которое испытал Нэо, впервые увидев матрицу.

__Замыкание — это когда функция имеет возможность запомнить и достать свою лексическую область видимости, даже когда функция выполняется вне этой области.__

```js
function foo() {
	var a = 2;
	function bar() { //`bar` имеет доступ к переменной `a` во внешней лексической области
		console.log( a ); // 2
		// `bar` имеет замыкание с областью foo поскольку `bar` вложена внутри foo
	}
	bar();
}
foo();
//Другой пример
function foo() {
	var a = 2;
	function bar() {
		console.log( a );
	}
	return bar;// передаем функцию как значение
}
//Выполняем foo() передавая baz функцию bar
var baz = foo();
baz(); // 2 -- воу воу да это же замыкание.
//есть другие способы передачи функций как значений.
function foo() {
	var a = 2;
	function baz() {
		console.log( a ); // 2
	}
	bar( baz );//Передаем функцию baz функции bar и вызывем внутреннюю функцию помеченную как fn()
}//но поскольку baz замыкается на область foo() мы все ещ будем иметь доступ к переменной `a`
function bar(fn) {
	fn(); // Смотри мам, замыкание))
}


//Теперь посмотрим на примеры из реального кода
function wait(message) {
	setTimeout( function timer(){// обозначили функцию timer внутри setTimeout 
		console.log( message );
	}, 1000 );
}
//timer замыкается на область видимости wait и таким образом получает доступ к message
//даже спустя 1000 милисекунд при выполнении анонимной функции которая в свою очередь вызовет функцию timer

wait( "Hello, closure!" );
// Если же мы говорим о немедленно вызывающихся функциях
var a = 2;
(function IIFE(){
	console.log( a );
})()
/*  Строго говоря это не замыкание потому что функция вызывается не вне своей лексической области
Она вызывается там же где была объявлена.
*/
```

После выполнения `foo()` мы ожидаем что внутренняя область `foo()` сотрется, поскольку больше нет необходимости ее хранить, а движку нужно освободить память. 

Но вся магия замыканий в том, что этого не происходит. Потому как эта область все еще используется.

Кто ее использует? Да функция `bar()` собственной персоной.
Учитывая, где была объявлена `bar()`, она имеет замыкание с той областью видимости, и потому ссылка на нее, будет храниться нетронутой, до тех пор пока она позже не понадобится `bar()`. 

Эта ссылка и есть замыкание. Через несколько микросекунд будет вызвана функция `baz()`, которая в свою очередь вызовет `bar()` и получит доступ к переменной `a`, как мы и ожидаем. Замыкание позволяет функции продлить доступ к той лексической области, где она была объявлена.

### Замыкания и циклы.

На самом деле получаем число 6 с 1-секундным интервалом. Чегоооо?))Завершающее условие цикла если `i` НЕ `<=5`. И первым таким случаем будет `i = 6`.

Даже если мы сделаем выдержку 0 милисекунд каждую итерацию цикла, все колбэки функции `setTimeout` будут запускаться строго после завершения действий цикла. 

Все 5 функций будут замыкаться на глобальную область видимости где только одно `i` и оно равно 6.

Так работает цикл. Нам нужно создать свою область внутри цикла (со своими `i` и блекджеком), на которую мы будем замыкаться каждую итерацию.

```js
for (var i=1; i<=5; i++) {
	setTimeout( function timer(){
		console.log( i );
	}, i*1000 );
}
for (var i=1; i<=5; i++) {
	(function(){
		setTimeout( function timer(){
			console.log( i );
		}, i*1000 );
	})();
}//  снова выводим 6
//если приглядется поближе то мы всего лишь создали еще одну лексическую область видимости
//Нужно добавить в лексическую область видимости кое-что полезное нам
//например запись значения i в переменную j каждую итерацию
for (var i=1; i<=5; i++) {
	(function(){
		var j = i;
		setTimeout( function timer(){
			console.log( j );
		}, j*1000 );
	})();
}
// или более элегантный вариант где мы передаем i в качестве аргумента НВФ(IIFE)
for (var i=1; i<=5; i++) {
	(function(j){
		setTimeout( function timer(){
			console.log( j );
		}, j*1000 );
	})( i );//передаем i в качестве аргумента каждую итерацию
}
/*По сути мы должны создать блочную видимость для каждой итерации цикла
И почему бы это не сделать используя let
*/
for (var i=1; i<=5; i++) {
	let j = i; // йеее блочная видимость для замыкания
	
	setTimeout( function timer(){
		console.log( j );
	}, j*1000 );
}
/* но при объявлении с помощью let переменной для цикла она будет объявляться  не один раз на весь
цикл а каждую итерацию */
for (let i=1; i<=5; i++) {
	setTimeout( function timer(){
		console.log( i );
	}, i*1000 );
}
````

### Модули

```js
function CoolModule() {
	var something = "cool";
	var another = [1, 2, 3];
	function doSomething() {
		console.log( something );
	}
	function doAnother() {
		console.log( another.join( " ! " ) );
	}
	return {
		doSomething: doSomething,
		doAnother: doAnother
	};
}
var foo = CoolModule();
foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3

```

Замыкания также используются в модулях.

1. Создаем функцию `CoolModule()` ее нужно вызывать чтобы создать экземпляр модуля и соответственно области видимости и замыкания.

2. Функция `CoolModule()` вернет объект, в котором будут ссылки на внутренние функции, но, не на переменные. Мы сохраняем их скрытыми. Доступ к ним имеет только возвращаемый объект что является API нашего модуля.

3. Функции `doSomething()` и `doAnother()` замыкаются на внутреннюю область видимости модуля созданного при вызове функции `CoolModule()`.