---
layout: post
title: Вы не знаете JS. Область видимости и замыкания.
date: "2020-07-24"
tags: ["js"]
---

# Области видимости и замыкания 

Короткие, и надеюсь интересные, конспекты для систематизации знаний по JS после прочтения серии книг You Don't Know JS.

## Разбираемся с областями видимости

![start image](../../images/ydkjs-scope-closures/start.jpeg)
Что такое область видимости?

Основная функция любой программы заключается в возможности сохранять значения в переменных и при необходимости извлекать их. И переменные хранятся в области видимости (`scope`).

В языках программирования, которые компилируются есть три основных этапа при работе с кодом, прежде чем он будет выполнен:

Токенизация. Разбитие кода на кусочки, которые несут значение -токены.

Парсинг. Берем массив токенов и составляем из них абстрактное синтаксическое дерево.(AST — Abstract Syntax Tree)

Генерация кода.Берем AST и преобразуем его в исполняемый код (для работы с памятью и вот это всё)

У JS нет времени объяснять всё это, т.к. до исполнения кода, у JS есть лишь микросекунды на его обработку.

Попробуем понять как работает область видимости.

Движок (Engine)
Image for post
Отвечает за начало и окончание интерпретации кода и выполнение программы.
Компилятор (Compiler).
Image for post
Один из друзей Движка. Делает грязную работу типа парсинга и генерации исполняемого кода.

Область видимости (Scope).
Image for post
Другой бро Движка: собирает и обслуживает список поиска всех объявленных идентификаторов (переменных)а также следит за соответствием правилам для исполняемого кода.
На простом примере:
var a = 2;
Что делает компилятор
Встретив var a, компилятор спрашивает у области видимости может такая переменная уже есть в области. И если она уже есть компилятор игнорит объявление переменной и едет дальше. Если же такой переменной нет компилятор просит создать новую переменную с именем a у области видимости.
Потом компилятор готовит код для движка, чтобы потом выполнить присвоение a = 2 . При этом Движок должен уточнить у области видимости если переменная есть в текущей области видимости движок будет использовать именно ее. Если нет — Движок поищет ее где — нибудь еще.
Если Движок ее не найдет, он прекратит поиски и сформирует ошибку.
Движок может производить как левосторонний (LHS — Left Hand Side) так и правосторонний (RHS — Right Hand Side) поиск. Поиск распределяется по отношению к оператору присвоения = .
console.log( a );// правосторонний поиск
a = 2; //левосторонний поиск
function foo(a) {
    console.log( a ); // 2
}
foo( 2 );//1) RHS при вызове функции foo() 
//2)LHS при передаче аргумента a значения 2 происходит присвоение 
//a = 2;
Представим разговор Движка и Области видимости
Engine: Привет Scope, у меня тут RHS ссылка для foo. Слышал про такое?
Scope: Да, конечно. Интерпретатор только что объявил foo. Это функция. Вот она.
Engine: Круто, спасибо! OK, выполняю foo.
Engine: Слушай область видимости, тут еще LHS ссылка для a, слышал о ней?
Scope: Да. Буквально только что интерпретатор объявил ее как параметр для foo. Вот она.
Engine: Как всегда кстати)). И снова спасибо. Пришло время присвоить значение 2 переменной a.
Engine: Сорри за беспокойство. Мне нужно посмотреть RHS для console. Не слышал?
Scope: Нет проблем, Engine, это то,что я делаю целый день. Да есть объект console. Он встроенный. Вот пользуйся.
Engine: Отлично. Поищем — ка log(..). OK, это функция.
Engine: Йоу, Scope. Можешь помочь с RHS ссылкой на a.
Я вроде помню его, просто хотел еще раз уточнить.
Scope: Да ты прав, Engine. Та же переменная, значение не изменилось. Можешь пользоваться.
Engine: Круто, значит передаем значение 2 переменной a , а ее затем функции log(..).
…
Также как функция или блок могут быть вложены в другой блок или функцию области видимости могут быть вложенными.
function foo(a) {
    console.log( a + b );
}
var b = 2;
foo( 2 ); // 4
Engine: “Привет, Scope из функции foo, слышал что нибудь про b? Только что получил RHS ссылку для него.”
Scope: “Не не слышал. Поищи в другом месте.”
Engine: “Хэй, Scope снаружи функции foo, о да ты глобальный scope, OK
круто. Слышал что нибудь про b? Только что получил RHS ссылку для него.”
Scope: “Да конечно. Вот — пользуйся.”
Итак, движок будет искать ссылку начиная с текущей области видимости и заканчивая глобальной.
Image for post
Если же и в глобальной области ссылка не будет найдена то в зависимости от того какую ссылку мы ищем RHS или LHS могут быть разные результаты.
Если поиск идет по RHS ссылке, то есть по правой стороне и переменная не найдена, то мы получим ReferenceError.
Если поиск идет по LHS ссылке, то есть по левой стороне и переменная не найдена, то все зависит от того используем мы StrictMode или нет.
Если не используем StrictMode, то в глобальной области будет создана переменная с указанным именем и передана движку. Если же включен StrictMode то мы также получим Reference Error.
Ну, а если поиск по RHS увенчался успехом, но мы пытаемся сделать с результатами поиска что нибудь противоестественное. Например, использовать нефункцию как функцию, или ссылаться на свойства, значения которых null или undefined, то мы получим TypeError.
Лексическая область видимости.
Для языков программирования используется два вида областей видимости: лексическая и динамическая. Для JS используется лексическая область видимости.

В приведенном выше примере кода, движок выполнит console.log() а значит будет искать три переменные a b и c . Движок начнет искать с самой глубокой области видимости — области видимости функции bar() . Поскольку переменной a нет в области видимости функции bar() , поиск перейдет на ближайшую область видимости — область видимости функции foo() . То же самое для переменной b . Ну а c будет найдена в области видимости bar() . Если a и c будут также объявлены в bar() то при поиске мы не попадем в область функции foo() . Поиск всегда останавливается как только найдет первый результат.
Неважно где и каким образом функция вызывается, лексическая область видимости всегда определяется там, где функция была объявлена.