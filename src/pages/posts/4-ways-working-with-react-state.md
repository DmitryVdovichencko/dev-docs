---
title: 4 подхода для работы с состоянием компонентов в React.
description: >-
  Перевод статьи Cory House  Handling State in React: Four Immutable Approaches
  to Consider.
date: '2019-08-24T08:16:49.561Z'
categories: []
keywords: []
tags: ["react"]
---

# 4 подхода для работы с состоянием компонентов в React.

![](https://miro.medium.com/max/700/1*xtYEQUYzu5qUKuXg-SGx-g.jpeg)

Перевод статьи [Cory House](https://twitter.com/housecor) [Handling State in React: Four Immutable Approaches to Consider](https://www.freecodecamp.org/news/handling-state-in-react-four-immutable-approaches-to-consider-d1f5c00249d5/).

На сегодня, возможно самая сложная тема для понимания в React — это состояние: `state`.

Представим, у вас есть форма для редактирования пользователем. Распространенный подход: создать один обработчик изменений, чтобы работать с изменением любого поля формы.

Выглядит это примерно так:

О четвертой строке кода стоит поволноваться. Четвертая строка действительно меняет состояние `state`, потому что переменная `user` ссылается на `state`. В `react` состояние трактуется как неизменное.

Из [документации React](https://facebook.github.io/react/docs/react-component.html#state) :

> Никогда не меняйте `this.state` напрямую, так как вызов `setState()`, в итоге, может перезаписать те изменения, что вы сделали.   
> Работайте с состоянием `this.state`, как будто оно неизменно.

Почему?

`setState` работает под капотом. Это означает, что принудительное изменение состояния `state` может быть перезаписано, когда выполнится `setState`.  
Если вы объявили метод `shouldComponentUpdate`, вы не можете использовать проверку на равенство `===` внутри, т.к. ссылка на объект не изменится. Так что, вышеупомянутый метод может еще и повлиять на производительность.  
Вообще, примеры выше часто работают нормально, но, чтобы избежать крайних случаев, работайте с состоянием так, как будто оно неизменно.

Есть четыре способа правильной работы с состоянием `state`:

#### Способ 1: Object.assign

`Object.assign` создает копию объекта. Первый параметр указывает куда мы будем его копировать, остальные параметры это объекты, которые мы хотим скопировать. Если исправить пример выше, то изменения коснутся строки 3:

В строке 3, я говорю :

> Создай новый пустой объект и добавь туда все свойства из`this.state.user`. В результате получится отдельная копия объекта `user,` который хранится в `state`.  
> Теперь, я могу спокойно менять объект в строке 4 — это полностью независимый объект от того, что хранится в `state`.

Убедитесь, что есть полифилл для метода `Object.assign,` т.к. он не поддерживается в IE и не транспилируется Babel.

4 источника для ознакомления:

*   [object-assign](https://www.npmjs.com/package/object-assign)
*   [The MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
*   [Babel Polyfill](https://babeljs.io/docs/usage/polyfill/)
*   [Polyfill.io](https://polyfill.io/v2/docs/features/#Object_assign)

#### Способ 2: Object Spread

Реализация `Object spread` на данный момент находится на стадии 3 и эта возможность языка может быть транспилирована Babel.  
Этот способ более краткий:

В строке 3, я говорю:

> Используй все свойства `this.state.user` для создания нового объекта, затем установи для свойства `[name]` новое значение из `event.target.value`.

Таким образом, этот метод похож на применение `Object.assign`, но он имеет 2 преимущества:

1.  Не требуются полифилы, Babel может транспилировать код
2.  Более краткая форма записи

Можно даже использовать деструктуризацию и уместить все в одну строку:

Я деструктурировал объект `event` для получения ссылки на `event.target`. Затем, я объявляю, что состояние `state` должно быть копией `this.state.user` с актуальным значением свойства `[target.name]`. Получилось лаконичненько, пожалуй это мой любимый способ для обработчиков изменений.

Эти два способа самые распространенные и простые методы поддержки состояния `state` неизменным. Хотите больше полномочий при работе с состоянием? Тогда посмотрите на следующие два способа.

#### Способ 3: Immutability Helper

[Immutability-helper](https://github.com/kolodny/immutability-helper) — внешняя библиотека для копирования данных без изменения исходных данных. Эта библиотека представлена в документации [React](https://facebook.github.io/react/docs/update.html).

В строке 5:

> Я вызываю `merge` — одну из [команд](https://github.com/kolodny/immutability-helper#available-commands) `immutability-helper`. Как и в случае с `Object.assign`, первым параметром я передаю целевой объект, а затем определяю свойство, которое будет добавлено и объединено.

Правда, в случае с `immutability-helper` есть больше возможностей. Здесь используется синтаксис, вдохновленный языком запросов `MongoDB`, что предоставляет [множество мощных способов для работы с неизменяемыми данными](https://github.com/kolodny/immutability-helper#available-commands).

#### Способ 4: Immutable.js

Хотите программно применять неизменность? Посмотрите на [immutable.js](https://facebook.github.io/immutable-js/). Эта библиотека поддерживает неизменные структуры данных.

Пример с использованием неизменяемой `map`:

Три шага для использования `immutable`:

1.  Импортируем `immutable`.
2.  Устанавливаем `state` в неизменяемый `map` в `constructor`
3.  Используем метод `set` в обработчике изменений для создания новой копии объекта `user`

Вся красота `immutable.js` в том, что : если попытаться изменить `state` напрямую, возникнет ошибка. С предыдущими способами, легко об этом забыть, и React не предупредит вас, когда вы попытаетесь изменить `state` напрямую.

Недостатки `immutable.js :`

*   Раздуваем бандл. `Immutable.js` добавляет `57K` в минифицированном виде. [Использование библиотек типа Preact могут заменить React всего](https://preactjs.com/) `[3К](https://preactjs.com/)`, что довольно тяжело принять.
*   Синтаксис. Вам придется ссылаться на свойства объекта через строки и точно также вызывать методы вместо доступа напрямую. Я предпочитаю использовать `user.name` чем `user.get('name')`.
*   YATTL (Yet another thing to learn) — Еще одна вещь для изучения — любому, кто присоединится к вашей команде, потребуется изучить еще один API для доступа и записи данных также как и новые типы данных.

Парочка альтернатив:

*   [seamless-immutable](https://github.com/rtfeldman/seamless-immutable)
*   [react-copy-write](https://github.com/aweary/react-copy-write)

#### Предупреждение: Берегитесь Вложенных Объектов!

Варианты 1 и 2 (`Object.assign Object spread`) делают только поверхностную копию. Так что, если ваш объект содержит вложенные объекты, они будут скопированы по ссылке, а не по значению. В этом случае если вы измените вложенный объект, вы повлияете и на исходный вложенный объект.

Будьте хирургически аккуратны с тем, что копируете. Не копируйте все подряд. Копируйте объекты,которые изменились. [Immutability-helper](https://github.com/kolodny/immutability-helper) легко это делает. Также как и альтернативы: [immer](https://github.com/mweststrate/immer), [updeep](https://github.com/substantial/updeep), или [вот длинный список других вариантов](https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md#immutable-update-utilities).

Вы можете поддаться искушению использовать инструменты глубокого слияния, например [clone-deep](https://www.npmjs.com/package/clone-deep) или [lodash.merge](https://lodash.com/docs/#merge), **но избегайте глубокого копирования**.

1.  Глубокое копирование дорого обходится
2.  Глубокое копирование нерационально ( в отличие от копирования только того, что изменилось)
3.  Глубокое копирование провоцирует необязательный рендеринг, т.к. React думает что все изменилось хотя возможно фактически изменился только определенный дочерний объект.

Спасибо Дэну Абрамову за рекомендации, которые я указал выше.

#### Последний совет: Подумайте над использованием функции setState

Одна загвоздка может вас зацепить:

> `setState()` не изменяет состояние `this.state` немедленно, но создает ожидание перехода состояния. Попытка доступа к `this.state` после вызова этого метода, потенциально может вернуть существующее значение.

Как только запустится вызов `setState`, код вроде этого приведет к багу:

Если вы хотите запустить код после завершения вызова `setState`, используйте колбэк `setState`:

#### Мой выбор

Я предпочитаю простоту и легкость второго варианта: `Object spread`. Он не требует полифиллов или сторонних библиотек, я могу объявлять обработчик изменений в одну строку и могу позаботиться только о том, что изменяется. Что касается работы с вложенными объектами я бы предпочел [Immer](https://github.com/mweststrate/immer)

[![](https://cdn-images-1.medium.com/max/800/1*xhJGZsL0sh-k1BpESYirNg.png)](http://pluralsight.com/author/cory-house)

[Cory House](https://twitter.com/housecor) автор [многих курсов JavaScript, React, программированию, .NET, и других на Pluralsight](http://pluralsight.com/author/cory-house). Он является главным консультантом [reactjsconsulting.com](http://www.reactjsconsulting.com/), архитектором программного обеспечения VinSolutions, a Microsoft MVP, и обучает разработчиков программного обеспечения по всему миру фронтенду и чистому кодингу. Следите за его твитами о фронтенд разработке здесь: [@housecor](http://www.twitter.com/housecor).