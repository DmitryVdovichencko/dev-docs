(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{jvUr:function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return m})),a.d(t,"default",(function(){return p}));a("rzGZ"),a("Dq+y"),a("8npG"),a("Ggvi"),a("E5k/"),a("q1tI");var n=a("7ljp");var m={title:"4 подхода для работы с состоянием компонентов в React.",description:"Перевод статьи Cory House  Handling State in React: Four Immutable Approaches to Consider.",date:"2019-08-24T08:16:49.561Z",categories:[],keywords:[],tags:["react"]},l={_frontmatter:m},c="wrapper";function p(e){var t=e.components,a=function(e,t){if(null==e)return{};var a,n,m={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(m[a]=e[a]);return m}(e,["components"]);return Object(n.mdx)(c,Object.assign({},l,a,{components:t,mdxType:"MDXLayout"}),Object(n.mdx)("h1",null,"4 подхода для работы с состоянием компонентов в React."),Object(n.mdx)("p",null,Object(n.mdx)("img",Object.assign({parentName:"p"},{src:"https://miro.medium.com/max/700/1*xtYEQUYzu5qUKuXg-SGx-g.jpeg",alt:null}))),Object(n.mdx)("p",null,"Перевод статьи ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://twitter.com/housecor"}),"Cory House")," ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://www.freecodecamp.org/news/handling-state-in-react-four-immutable-approaches-to-consider-d1f5c00249d5/"}),"Handling State in React: Four Immutable Approaches to Consider"),"."),Object(n.mdx)("p",null,"На сегодня, возможно самая сложная тема для понимания в React — это состояние: ",Object(n.mdx)("inlineCode",{parentName:"p"},"state"),"."),Object(n.mdx)("p",null,"Представим, у вас есть форма для редактирования пользователем. Распространенный подход: создать один обработчик изменений, чтобы работать с изменением любого поля формы."),Object(n.mdx)("p",null,"Выглядит это примерно так:"),Object(n.mdx)("p",null,"О четвертой строке кода стоит поволноваться. Четвертая строка действительно меняет состояние ",Object(n.mdx)("inlineCode",{parentName:"p"},"state"),", потому что переменная ",Object(n.mdx)("inlineCode",{parentName:"p"},"user")," ссылается на ",Object(n.mdx)("inlineCode",{parentName:"p"},"state"),". В ",Object(n.mdx)("inlineCode",{parentName:"p"},"react")," состояние трактуется как неизменное."),Object(n.mdx)("p",null,"Из ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://facebook.github.io/react/docs/react-component.html#state"}),"документации React")," :"),Object(n.mdx)("blockquote",null,Object(n.mdx)("p",{parentName:"blockquote"},"Никогда не меняйте ",Object(n.mdx)("inlineCode",{parentName:"p"},"this.state")," напрямую, так как вызов ",Object(n.mdx)("inlineCode",{parentName:"p"},"setState()"),", в итоге, может перезаписать те изменения, что вы сделали. ",Object(n.mdx)("br",{parentName:"p"}),"\n","Работайте с состоянием ",Object(n.mdx)("inlineCode",{parentName:"p"},"this.state"),", как будто оно неизменно.")),Object(n.mdx)("p",null,"Почему?"),Object(n.mdx)("p",null,Object(n.mdx)("inlineCode",{parentName:"p"},"setState")," работает под капотом. Это означает, что принудительное изменение состояния ",Object(n.mdx)("inlineCode",{parentName:"p"},"state")," может быть перезаписано, когда выполнится ",Object(n.mdx)("inlineCode",{parentName:"p"},"setState"),".",Object(n.mdx)("br",{parentName:"p"}),"\n","Если вы объявили метод ",Object(n.mdx)("inlineCode",{parentName:"p"},"shouldComponentUpdate"),", вы не можете использовать проверку на равенство ",Object(n.mdx)("inlineCode",{parentName:"p"},"===")," внутри, т.к. ссылка на объект не изменится. Так что, вышеупомянутый метод может еще и повлиять на производительность.",Object(n.mdx)("br",{parentName:"p"}),"\n","Вообще, примеры выше часто работают нормально, но, чтобы избежать крайних случаев, работайте с состоянием так, как будто оно неизменно."),Object(n.mdx)("p",null,"Есть четыре способа правильной работы с состоянием ",Object(n.mdx)("inlineCode",{parentName:"p"},"state"),":"),Object(n.mdx)("h4",null,"Способ 1: Object.assign"),Object(n.mdx)("p",null,Object(n.mdx)("inlineCode",{parentName:"p"},"Object.assign")," создает копию объекта. Первый параметр указывает куда мы будем его копировать, остальные параметры это объекты, которые мы хотим скопировать. Если исправить пример выше, то изменения коснутся строки 3:"),Object(n.mdx)("p",null,"В строке 3, я говорю :"),Object(n.mdx)("blockquote",null,Object(n.mdx)("p",{parentName:"blockquote"},"Создай новый пустой объект и добавь туда все свойства из",Object(n.mdx)("inlineCode",{parentName:"p"},"this.state.user"),". В результате получится отдельная копия объекта ",Object(n.mdx)("inlineCode",{parentName:"p"},"user,")," который хранится в ",Object(n.mdx)("inlineCode",{parentName:"p"},"state"),".",Object(n.mdx)("br",{parentName:"p"}),"\n","Теперь, я могу спокойно менять объект в строке 4 — это полностью независимый объект от того, что хранится в ",Object(n.mdx)("inlineCode",{parentName:"p"},"state"),".")),Object(n.mdx)("p",null,"Убедитесь, что есть полифилл для метода ",Object(n.mdx)("inlineCode",{parentName:"p"},"Object.assign,")," т.к. он не поддерживается в IE и не транспилируется Babel."),Object(n.mdx)("p",null,"4 источника для ознакомления:"),Object(n.mdx)("ul",null,Object(n.mdx)("li",{parentName:"ul"},Object(n.mdx)("a",Object.assign({parentName:"li"},{href:"https://www.npmjs.com/package/object-assign"}),"object-assign")),Object(n.mdx)("li",{parentName:"ul"},Object(n.mdx)("a",Object.assign({parentName:"li"},{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"}),"The MDN docs")),Object(n.mdx)("li",{parentName:"ul"},Object(n.mdx)("a",Object.assign({parentName:"li"},{href:"https://babeljs.io/docs/usage/polyfill/"}),"Babel Polyfill")),Object(n.mdx)("li",{parentName:"ul"},Object(n.mdx)("a",Object.assign({parentName:"li"},{href:"https://polyfill.io/v2/docs/features/#Object_assign"}),"Polyfill.io"))),Object(n.mdx)("h4",null,"Способ 2: Object Spread"),Object(n.mdx)("p",null,"Реализация ",Object(n.mdx)("inlineCode",{parentName:"p"},"Object spread")," на данный момент находится на стадии 3 и эта возможность языка может быть транспилирована Babel.",Object(n.mdx)("br",{parentName:"p"}),"\n","Этот способ более краткий:"),Object(n.mdx)("p",null,"В строке 3, я говорю:"),Object(n.mdx)("blockquote",null,Object(n.mdx)("p",{parentName:"blockquote"},"Используй все свойства ",Object(n.mdx)("inlineCode",{parentName:"p"},"this.state.user")," для создания нового объекта, затем установи для свойства ",Object(n.mdx)("inlineCode",{parentName:"p"},"[name]")," новое значение из ",Object(n.mdx)("inlineCode",{parentName:"p"},"event.target.value"),".")),Object(n.mdx)("p",null,"Таким образом, этот метод похож на применение ",Object(n.mdx)("inlineCode",{parentName:"p"},"Object.assign"),", но он имеет 2 преимущества:"),Object(n.mdx)("ol",null,Object(n.mdx)("li",{parentName:"ol"},"Не требуются полифилы, Babel может транспилировать код"),Object(n.mdx)("li",{parentName:"ol"},"Более краткая форма записи")),Object(n.mdx)("p",null,"Можно даже использовать деструктуризацию и уместить все в одну строку:"),Object(n.mdx)("p",null,"Я деструктурировал объект ",Object(n.mdx)("inlineCode",{parentName:"p"},"event")," для получения ссылки на ",Object(n.mdx)("inlineCode",{parentName:"p"},"event.target"),". Затем, я объявляю, что состояние ",Object(n.mdx)("inlineCode",{parentName:"p"},"state")," должно быть копией ",Object(n.mdx)("inlineCode",{parentName:"p"},"this.state.user")," с актуальным значением свойства ",Object(n.mdx)("inlineCode",{parentName:"p"},"[target.name]"),". Получилось лаконичненько, пожалуй это мой любимый способ для обработчиков изменений."),Object(n.mdx)("p",null,"Эти два способа самые распространенные и простые методы поддержки состояния ",Object(n.mdx)("inlineCode",{parentName:"p"},"state")," неизменным. Хотите больше полномочий при работе с состоянием? Тогда посмотрите на следующие два способа."),Object(n.mdx)("h4",null,"Способ 3: Immutability Helper"),Object(n.mdx)("p",null,Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://github.com/kolodny/immutability-helper"}),"Immutability-helper")," — внешняя библиотека для копирования данных без изменения исходных данных. Эта библиотека представлена в документации ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://facebook.github.io/react/docs/update.html"}),"React"),"."),Object(n.mdx)("p",null,"В строке 5:"),Object(n.mdx)("blockquote",null,Object(n.mdx)("p",{parentName:"blockquote"},"Я вызываю ",Object(n.mdx)("inlineCode",{parentName:"p"},"merge")," — одну из ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://github.com/kolodny/immutability-helper#available-commands"}),"команд")," ",Object(n.mdx)("inlineCode",{parentName:"p"},"immutability-helper"),". Как и в случае с ",Object(n.mdx)("inlineCode",{parentName:"p"},"Object.assign"),", первым параметром я передаю целевой объект, а затем определяю свойство, которое будет добавлено и объединено.")),Object(n.mdx)("p",null,"Правда, в случае с ",Object(n.mdx)("inlineCode",{parentName:"p"},"immutability-helper")," есть больше возможностей. Здесь используется синтаксис, вдохновленный языком запросов ",Object(n.mdx)("inlineCode",{parentName:"p"},"MongoDB"),", что предоставляет ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://github.com/kolodny/immutability-helper#available-commands"}),"множество мощных способов для работы с неизменяемыми данными"),"."),Object(n.mdx)("h4",null,"Способ 4: Immutable.js"),Object(n.mdx)("p",null,"Хотите программно применять неизменность? Посмотрите на ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://facebook.github.io/immutable-js/"}),"immutable.js"),". Эта библиотека поддерживает неизменные структуры данных."),Object(n.mdx)("p",null,"Пример с использованием неизменяемой ",Object(n.mdx)("inlineCode",{parentName:"p"},"map"),":"),Object(n.mdx)("p",null,"Три шага для использования ",Object(n.mdx)("inlineCode",{parentName:"p"},"immutable"),":"),Object(n.mdx)("ol",null,Object(n.mdx)("li",{parentName:"ol"},"Импортируем ",Object(n.mdx)("inlineCode",{parentName:"li"},"immutable"),"."),Object(n.mdx)("li",{parentName:"ol"},"Устанавливаем ",Object(n.mdx)("inlineCode",{parentName:"li"},"state")," в неизменяемый ",Object(n.mdx)("inlineCode",{parentName:"li"},"map")," в ",Object(n.mdx)("inlineCode",{parentName:"li"},"constructor")),Object(n.mdx)("li",{parentName:"ol"},"Используем метод ",Object(n.mdx)("inlineCode",{parentName:"li"},"set")," в обработчике изменений для создания новой копии объекта ",Object(n.mdx)("inlineCode",{parentName:"li"},"user"))),Object(n.mdx)("p",null,"Вся красота ",Object(n.mdx)("inlineCode",{parentName:"p"},"immutable.js")," в том, что : если попытаться изменить ",Object(n.mdx)("inlineCode",{parentName:"p"},"state")," напрямую, возникнет ошибка. С предыдущими способами, легко об этом забыть, и React не предупредит вас, когда вы попытаетесь изменить ",Object(n.mdx)("inlineCode",{parentName:"p"},"state")," напрямую."),Object(n.mdx)("p",null,"Недостатки ",Object(n.mdx)("inlineCode",{parentName:"p"},"immutable.js :")),Object(n.mdx)("ul",null,Object(n.mdx)("li",{parentName:"ul"},"Раздуваем бандл. ",Object(n.mdx)("inlineCode",{parentName:"li"},"Immutable.js")," добавляет ",Object(n.mdx)("inlineCode",{parentName:"li"},"57K")," в минифицированном виде. ",Object(n.mdx)("a",Object.assign({parentName:"li"},{href:"https://preactjs.com/"}),"Использование библиотек типа Preact могут заменить React всего")," ",Object(n.mdx)("inlineCode",{parentName:"li"},"[3К](https://preactjs.com/)"),", что довольно тяжело принять."),Object(n.mdx)("li",{parentName:"ul"},"Синтаксис. Вам придется ссылаться на свойства объекта через строки и точно также вызывать методы вместо доступа напрямую. Я предпочитаю использовать ",Object(n.mdx)("inlineCode",{parentName:"li"},"user.name")," чем ",Object(n.mdx)("inlineCode",{parentName:"li"},"user.get('name')"),"."),Object(n.mdx)("li",{parentName:"ul"},"YATTL (Yet another thing to learn) — Еще одна вещь для изучения — любому, кто присоединится к вашей команде, потребуется изучить еще один API для доступа и записи данных также как и новые типы данных.")),Object(n.mdx)("p",null,"Парочка альтернатив:"),Object(n.mdx)("ul",null,Object(n.mdx)("li",{parentName:"ul"},Object(n.mdx)("a",Object.assign({parentName:"li"},{href:"https://github.com/rtfeldman/seamless-immutable"}),"seamless-immutable")),Object(n.mdx)("li",{parentName:"ul"},Object(n.mdx)("a",Object.assign({parentName:"li"},{href:"https://github.com/aweary/react-copy-write"}),"react-copy-write"))),Object(n.mdx)("h4",null,"Предупреждение: Берегитесь Вложенных Объектов!"),Object(n.mdx)("p",null,"Варианты 1 и 2 (",Object(n.mdx)("inlineCode",{parentName:"p"},"Object.assign Object spread"),") делают только поверхностную копию. Так что, если ваш объект содержит вложенные объекты, они будут скопированы по ссылке, а не по значению. В этом случае если вы измените вложенный объект, вы повлияете и на исходный вложенный объект."),Object(n.mdx)("p",null,"Будьте хирургически аккуратны с тем, что копируете. Не копируйте все подряд. Копируйте объекты,которые изменились. ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://github.com/kolodny/immutability-helper"}),"Immutability-helper")," легко это делает. Также как и альтернативы: ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://github.com/mweststrate/immer"}),"immer"),", ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://github.com/substantial/updeep"}),"updeep"),", или ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md#immutable-update-utilities"}),"вот длинный список других вариантов"),"."),Object(n.mdx)("p",null,"Вы можете поддаться искушению использовать инструменты глубокого слияния, например ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://www.npmjs.com/package/clone-deep"}),"clone-deep")," или ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://lodash.com/docs/#merge"}),"lodash.merge"),", ",Object(n.mdx)("strong",{parentName:"p"},"но избегайте глубокого копирования"),"."),Object(n.mdx)("ol",null,Object(n.mdx)("li",{parentName:"ol"},"Глубокое копирование дорого обходится"),Object(n.mdx)("li",{parentName:"ol"},"Глубокое копирование нерационально ( в отличие от копирования только того, что изменилось)"),Object(n.mdx)("li",{parentName:"ol"},"Глубокое копирование провоцирует необязательный рендеринг, т.к. React думает что все изменилось хотя возможно фактически изменился только определенный дочерний объект.")),Object(n.mdx)("p",null,"Спасибо Дэну Абрамову за рекомендации, которые я указал выше."),Object(n.mdx)("h4",null,"Последний совет: Подумайте над использованием функции setState"),Object(n.mdx)("p",null,"Одна загвоздка может вас зацепить:"),Object(n.mdx)("blockquote",null,Object(n.mdx)("p",{parentName:"blockquote"},Object(n.mdx)("inlineCode",{parentName:"p"},"setState()")," не изменяет состояние ",Object(n.mdx)("inlineCode",{parentName:"p"},"this.state")," немедленно, но создает ожидание перехода состояния. Попытка доступа к ",Object(n.mdx)("inlineCode",{parentName:"p"},"this.state")," после вызова этого метода, потенциально может вернуть существующее значение.")),Object(n.mdx)("p",null,"Как только запустится вызов ",Object(n.mdx)("inlineCode",{parentName:"p"},"setState"),", код вроде этого приведет к багу:"),Object(n.mdx)("p",null,"Если вы хотите запустить код после завершения вызова ",Object(n.mdx)("inlineCode",{parentName:"p"},"setState"),", используйте колбэк ",Object(n.mdx)("inlineCode",{parentName:"p"},"setState"),":"),Object(n.mdx)("h4",null,"Мой выбор"),Object(n.mdx)("p",null,"Я предпочитаю простоту и легкость второго варианта: ",Object(n.mdx)("inlineCode",{parentName:"p"},"Object spread"),". Он не требует полифиллов или сторонних библиотек, я могу объявлять обработчик изменений в одну строку и могу позаботиться только о том, что изменяется. Что касается работы с вложенными объектами я бы предпочел ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://github.com/mweststrate/immer"}),"Immer")),Object(n.mdx)("p",null,Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"http://pluralsight.com/author/cory-house"}),Object(n.mdx)("img",Object.assign({parentName:"a"},{src:"https://cdn-images-1.medium.com/max/800/1*xhJGZsL0sh-k1BpESYirNg.png",alt:null})))),Object(n.mdx)("p",null,Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"https://twitter.com/housecor"}),"Cory House")," автор ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"http://pluralsight.com/author/cory-house"}),"многих курсов JavaScript, React, программированию, .NET, и других на Pluralsight"),". Он является главным консультантом ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"http://www.reactjsconsulting.com/"}),"reactjsconsulting.com"),", архитектором программного обеспечения VinSolutions, a Microsoft MVP, и обучает разработчиков программного обеспечения по всему миру фронтенду и чистому кодингу. Следите за его твитами о фронтенд разработке здесь: ",Object(n.mdx)("a",Object.assign({parentName:"p"},{href:"http://www.twitter.com/housecor"}),"@housecor"),"."))}p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-posts-4-ways-working-with-react-state-md-d93541f8d506cd897422.js.map