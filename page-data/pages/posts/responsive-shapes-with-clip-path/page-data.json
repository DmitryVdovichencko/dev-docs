{"componentChunkName":"component---src-templates-blog-post-js","path":"/pages/posts/responsive-shapes-with-clip-path/","result":{"data":{"post":{"html":"<p>Перевод статьи <a href=\"https://blog.karenmenezes.com/\">Karen Menezes</a> <a href=\"https://www.smashingmagazine.com/2015/05/creating-responsive-shapes-with-clip-path/\">Creating Responsive Shapes With Clip-Path And Breaking Out Of The Box</a>. Публикуется с разрешения автора. Ссылка на оригинальную статью указана выше. С момента написания статьи 11.05.2015 статус спецификации не изменялся.</p>\n<p>Свойство CSS <code class=\"language-text\">clip-path</code> — ваш билет к изменению формы монотонных, боксовых разметок традиционно ассоциирующимся с простым, отзывчивым дизайном. Вы начнете мыслить нестандартно, буквально выходить за рамки, и шестиугольники, звезды и восьмиугольники начнут оживать на ваших веб страницах. Однажды попробовав <code class=\"language-text\">clip-path</code>, вы будете постоянно генерировать любые фигуры, просто настраивая несколько значений</p>\n<p>Несмотря на то что основным объектом этой статьи является использование <code class=\"language-text\">clip-path</code> для создания многоугольников с помощью CSS, все примеры поддерживают инлайновый SVG, для дополнительной поддержки в Firefox. Создание отзывчивых фигур с помощью SVG — простая задача, если вы хоть раз использовали <code class=\"language-text\">CSS clip-path</code>.</p>\n<p><strong>Clip-Path, в общих чертах</strong></p>\n<p>Вырезать фигуры, свойством <code class=\"language-text\">clip-path</code>, сродни вырезанию фигур (таких как круг или пятиугольник) из прямоугольного куска бумаги. Это свойство находится в спецификации “CSS Masking Module Level 1”. Состояние спецификации, “CSS masking поддерживает два значения для частичного или полного скрытия частей визуальных элементов: маскирование и обрезка”.</p>\n<p>Первая часть, т.е. маскирование, использует графический элемент, такие как изображение PNG, CSS градиент или SVG элемент, как маску для скрытия частей другого элемента.</p>\n<p>Вторая часть, т.е. <code class=\"language-text\">clip-path</code>, задействует замкнутый контур, который может быть базовой фигурой определенной в CSS или SVG используя тэг clipPath. Область внутри контура отобразится, а все что снаружи будет отсечено.</p>\n<p>Примечание: Маскирование выходит за пределы этой статьи, но на CSS-Tricks и HTML5 Rocks можно найти более подробную информацию.<br>\nНиже простая визуализация работы <code class=\"language-text\">clip-path</code>:</p>\n<p>Примечание: примеры из этой статьи, включая указанный выше, будут работать в Firefox а также в WebKit и Blink браузерах, включая Chrome, Safari и Opera.</p>\n<p><strong>Clip-Path это вам не Clip</strong></p>\n<p>Есть такое старое CSS 2.1 свойство <code class=\"language-text\">clip</code> , которое весьма ограничено, главным образом потому, что оно поддерживает только прямоугольную форму. Это свойство устарело, вместо него нужно использовать <code class=\"language-text\">clip-path</code>.</p>\n<p>Пример использования устаревшего синтаксиса:</p>\n<p>element {<br>\nclip: rect(30px, 30px, 20px, 20px);<br>\n}</p>\n<p><strong>Поддержка Clip-Path</strong></p>\n<p>В августе 2014, спецификация “CSS Masking Module” была опубликована как “Candidate Recommendation,” это шаг вперед по сравнению с ранним черновиком “Last Call Working Draft”. До того как мы посмотрим на поддержку в браузерах, важно рассмотреть разные способы применения clip-path к элементу, потому что поддержка в браузерах варьируется в зависимости от этих способов.</p>\n<p>Есть два способа применения clip-path:</p>\n<ol>\n<li>Базовые фигуры CSS из “CSS Shapes Module” предоставляют удобный способ использования clip-path. Доступны следующие варианты фигур: polygon, circle, ellipse и inset; inset для прямоугольных фигур.</li>\n<li>С помощью SVG можно, в качестве альтернативы, создать фигуру используя SVG и затем обрезать элемент по этой фигуре используя синтаксис URL. Есть два способа реализации:</li>\n<li>ссылкой на инлайновый SVG (т.е. SVG разметка будет размещена прямо на странице)</li>\n<li>ссылкой на внешний SVG документ. В обоих случаях, элемент clipPath внутри SVG используется чтобы обернуть элемент который определяет фигуру обрезки, будь то круг, многоугольник, или другой элемент.</li>\n</ol>\n<p>Сравните демо ниже в Firefox и в WebKit или Blink браузере, например Chrome, чтобы почувствовать разницу. Квадратные изображения означают ошибку при поддержке браузером. Примечание: третье изображение не показывается в Safari. Несмотря на широкий дебаггинг, решить проблему не удалось. Я была бы благодарна, если в секции комментов встретилось решение.</p>\n<p>Если вы тестировали пример кода выше в разных браузерах, то наверняка заметили, что поддержка клиппирования довольно странная, и на данный момент она основывается на выборе способов которые вы применяете чтобы обрезать элемент:</p>\n<ul>\n<li>с CSS: Chrome 24+, Safari 7+, Opera 15+, iOS 7.1+, Android 4.4+, Opera Mobile 24+ (Примечание: для поддержки в указанных браузерах необходимо использовать вендорные префиксы -webkit.)</li>\n<li>с SVG: все браузеры указанные выше и Firefox 3.5+</li>\n</ul>\n<p>Свойство clip-path пока не поддерживается Internet Explorer, но находится на рассмотрении как часть “Masking Module.”</p>\n<p>Примечание: Есть оговорка насчет поддержки SVG для клиппирования. Современные WebKit и Blink браузеры поддерживают клиппирование с SVG только если SVG — инлайновый (т.е. внутри документа). Ссылки на внешние SVG поддерживаются только в Firefox, что подтверждается в примере кода выше. Проект Chromium знает об этом баге и работает над ним.</p>\n<p>Давайте посмотрим преимущества CSS и SVG при использовании clip-path.</p>\n<p>Преимущества CSS</p>\n<ul>\n<li>Легкий для понимания простой синтаксис, по причине относительной простоты базовых CSS фигур.</li>\n<li>Отзывчивость легко достигается с помощью применения относительных единиц измерения, таких как проценты.</li>\n</ul>\n<p>Преимущества SVG</p>\n<ul>\n<li>Лучшая поддержка в браузерах, включая Firefox</li>\n<li>Вы можете обрезать сложные фигуры, использовать множество фигур и текст.</li>\n</ul>\n<p>Пока CSS предлагает свойство background-clip, которое поддерживает множество вариантов (включая нестандартные способы обрезки текста), ни background-clip ни CSS’ clip-path не достигают того, что можно сделать с помощью SVG обрезки в современных браузерах. Знакомство с clip-path через CSS, тем не менее, не такое пугающее (особенно если вы не знакомы с манипуляциями SVG) и подготовит вас к тонкостям клиппирования с SVG, также как в “CSS Shapes Module,” где содержимое выравнивается по форме элемента.</p>\n<p>Примечание: если вам не терпится окунуться во все тонкости SVG, <a href=\"https://www.sarasoueidan.com/blog/css-svg-clipping/\">обзор Sara Soueidan</a> будет хорошим началом.</p>\n<p>Давайте посмотрим на плюсы и минусы clip-path чтобы постепенно улучшить наш дизайн.</p>\n<p>Плюсы</p>\n<ul>\n<li>Браузеры, не поддерживающие свойство clip-path будут его игнорировать. Если вы используете его с осторожностью, пользователи неподдерживаемых браузеров ничего не заподозрят. Таким образом событие клика ограничено фигурой и ее внешними границами. Мы увидим это в примерах кода ниже.</li>\n<li>Вы можете использовать проценты или любые другие единицы длины такие как px или em, для определения координат с базовыми фигурами CSS. Относительные единицы такие как проценты могут быть использованы для создания отзывчивых фигур, идеальных для адаптивного дизайна.</li>\n</ul>\n<p>Минусы</p>\n<ul>\n<li>Все границы, тени и контуры снаружи области обрезки будут отсечены. Вы можете добавить границу и ожидать что это будет выполнено. Посмотрим на некоторые альтернативы ниже.</li>\n<li>Спецификация еще не достигла стадии “Recommendation”, так что всегда есть шанс, что синтаксис будет временно изменен.</li>\n<li>Сообщалось о нескольких багах при использовании clip-path и 3Д трансформаций, переходов и проразчности, они будут рассмотрены в примерах далее. Будьте осторожны и избегайте комбинировая свойств, которые могут спровоцировть эти проблемы.</li>\n</ul>\n<p><strong>Clip-Path с использованием polygon: использование и синтаксис</strong></p>\n<p>Примеры кода ниже сфокусированы на использовании многоугольников в дизайне. Синтаксис для базовых фигур (т.е. прямоугольник, круг и эллипс) достаточно прост, и вы можете сделать с ними достаточно много. Многоугольники, тем не менее, практически открывают дверь к бесконечному числу фигур.</p>\n<p>Базовый синтаксис для многоугольника выглядит следующим образом:</p>\n<p>.element { clip-path: polygon(x1 y1, x2 y2, x3 y3, …); }</p>\n<p>Каждая пара аргументов в списке представляет координаты по осям <code class=\"language-text\">x</code> и <code class=\"language-text\">y</code> вершин многоугольника.</p>\n<p>Вот — как это выглядит в реальном мире (не считая текущей поддержки версии с префиксом WebKit):</p>\n<p>.element { clip-path: polygon(0 100%, 0 0, 100% 0, 80% 100%); }</p>\n<p>Добавим поддержку для Firefox с помощью ссылки на инлайновый SVG:</p>\n<p>.element { clip-path: url(“#clip-shape”); }</p>\n<p>Вот как выглядит наш селектор с кроссбраузерной поддержкой:</p>\n<p>.element {<br>\n-webkit-clip-path: polygon(0 100%, 0 0, 100% 0, 80% 100%);<br>\nclip-path: polygon(0 100%, 0 0, 100% 0, 80% 100%);<br>\n-webkit-clip-path: url(“#clip-shape”); /* required for    Webkit/Blink browsers if you’re using only inline SVG clipping paths, but not CSS clip-path */<br>\nclip-path: url(“#clip-shape”);<br>\n}</p>\n<p>Ниже представлен код инлайнового SVG, который необходимо добавить в разметку.</p>\n<p>&#x3C;svg width=”0\" height=”0\"><br>\n<defs><br>\n<clipPath id=”clip-shape” clipPathUnits=”objectBoundingBox”><br>\n&#x3C;polygon points=”0 1, 0 0, 1 0, 0.8 1\" /><br>\n</clipPath><br>\n</defs><br>\n</svg></p>\n<p>И окончательный пример кода с многоугольником:</p>\n<p>Вы можете создать отзывчивый SVG для обрезки в следующем порядке:</p>\n<ul>\n<li>Установите width и height для SVG в 0.</li>\n<li>Назначьте ID для clipPath элемента внутри SVG, на который можно ссылаться в CSS. Вы можете использовать инлайновый или внешний SVG, держа в уме поддержку браузеров, о которой говорилось ранее.</li>\n<li>Используйте значения координат в процентах назначенные в CSS clip-path. Просто делите их на 100 и уберите единицы измерения SVG.<br>\nУстановите значения атрибута clipPathUnits для objectBoundingBox, таким образом фигура обрезки послужит границами HTML элемента на который она ссылается.</li>\n</ul>\n<p><a href=\"http://demosthenes.info/blog/1007/Combining-CSS-clip-path-and-Shapes-for-New-Layout-Possibilities\">Dudley Storey</a> может рассказать больше об этом.</p>\n<p>Давайте посмотрим на примере как составить координаты для многоугольника.</p>\n<p>Итак у нас есть изображение, которое обрезано. Фоновым цветом обозначены габариты оригинального изображения. Ячейки с координатами просто абсолютно спозиционированные дивы, положение которых, соответствует координатам многоугольника в процентах. Вы увидите, что они сохраняют свою позицию, даже даже если вы измените ширину окна браузера (например, до 400px или более).</p>\n<p><strong>Реальные примеры использования Clip-Path</strong></p>\n<p>Примечание: Каждый пример кода в этой статье использует clip-path с CSS но также имеет инлайновый SVG в разметке с классом clip-svg, который просто обнуляет значения высоты и ширины SVG. В качестве альтернативы, вы можете удалить класс и обнулить высоту и ширину прямо в разметке SVG.</p>\n<p><em>Пример 1: Обрезаем изображение до разных многоугольных фигур</em></p>\n<p>В данном случае нам понадобится определение многоугольника, это плоская замкнутая фигура состоящая из прямых линий.</p>\n<p>Таким образом, фигура не может быть многоугольником если содержит кривые, разомкнута, или состоит менее чем из трех отрезков. Самые часто встречающиеся многоугольники: треугольники, четырехугольники, пятиугольники и шестиугольники. Даже фигура звезды является многоугольником, т.к. границы многоугольника связаны между собой.</p>\n<p>Примечание: Изображения в примерах — отзывчивые. Используя решение для отзывчивости изображений img { max-width: 100%; height: auto; } и адаптивные области обрезки для CSS и SVG, мы делаем наши многоугольники пропорционально уменьшающимися и увеличивающимися.</p>\n<p>Этот пример является результатом упражнений по назначению координат для многоугольных фигур. В примере добавлены несколько фигур, которые вы можете использовать для своего дизайна. При наведении курсора на каждое изображение, вы увидите соотношение сторон оригинального изображения.</p>\n<p>Ничто не сравнится с особенным <a href=\"http://bennettfeely.com/clippy\">Clippy</a> , GUI инструментом от Bennett Feely для визуализации фигур. Все координаты для всех существующих фигур указаны в процентах, а также есть вариант с настраиваемым многоугольником. Это поворотный момент. Вы можете использовать Clippy для создания фигур обрезки и SVG для них, с целью лучшей поддержки в браузерах.</p>\n<p><em>Пример 2: Анимация базовых фигур с помощью переходов CSS</em></p>\n<p>Наведите курсор на фиолетовый шестиугольник. Он трансформируется в восьмиугольник. Тем не менее, переход CSS не сработал.</p>\n<p>Причина такого поведения объяснена в статье Sara Soueidan об анимации фигур CSS : “ Число точек конечной фигуры должно соответствовать числу точек начальной фигуры.” Это вполне разумно!</p>\n<p>Т.к. шестиугольник имеет шесть пар координат вершин, давайте добавим еще две пары дублирующих координат, чтобы достичь числа координат для восьмиугольника. эти дублирующие пары координат никак не повлияют на шестиугольник.</p>\n<p>Так выглядит стандартное объявление шести пар координат для шестиугольника:</p>\n<p>clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);</p>\n<p>А это объявление шестиугольника с восемью парами координат (первые две вершины продублированы):</p>\n<p>clip-path: polygon(50% 0%, 50% 0%, 100% 25%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);</p>\n<p>Теперь, при трансформации фигуры, переход будет плавным, как в примере ниже.</p>\n<p>Примечание: Для браузеров поддерживающих области обрезки через SVG (а именно Firefox), нам понадобится добавить SMIL анимацию для реализации перехода при наведении. Согласно SMIL спецификации, анимации могут использоваться для изменения контуров и точек фигур SVG, которое невозможно выполнить средствами CSS.</p>\n<p>Помните, что некоторые осуждают использование SMIL в Chrome и Chromium при этом фокусируясь на внедрении Web Animations API, которое, к сожалению, пока на стадии раннего черновика.</p>\n<p>В примере ниже, вы можете увидеть, что мы анимировали вершины многоугольника между событиями указателя мыши mouseover и mouseout events в течение 0.2 секунд. Обратите внимание на тэг <animate> в SVG разметке.</p>\n<p><em>Пример 3: Добавляем границы для обрезанного объекта.</em></p>\n<p>Короче, границы, контуры и тени that находящиеся снаружи обрезаемой области будут удалены.</p>\n<p>Меня немного опечалил этот факт, и я решила отправить запрос представителям W3C рабочей группы CSS. Тем не менее, в итоге оказалось, что нет способа реализовать это при использовании базовых фигур. Dirk Schulze ответил на мой запрос: “Да, все операции отрисовки,которые принадлежали элементу будут обрезаны. Это включает контуры и границы.”</p>\n<p>Посмотрите на пример кода ниже. Наведите курсор на ромб с частичными границами чтобы увидеть оригинальную, полную версию со всеми границами.</p>\n<p>Конечно, мы всегда можем использовать CSS хак чтобы получить границу, к чему я в итоге и решила прибегнуть — старый добрый генерируемый контент.</p>\n<p>В примере ниже создается копия элемента через псевдо-элемент (content:after) с абсолютным позиционированием. Получается иллюзия границы, позволяя нам использовать интересные эффекты, такие как граница с градиентом во втором восьмиугольнике и добавление тени с помощью CSS фильтра на третьем (не очень симпатично, зато работает). Заметьте, что that CSS фильтры на текущий момент работают только в Firefox и в WebKit и в Blink браузерах.</p>\n<p><em>Пример 4: Используем CLIP-PATH для создания “бриллиантовой” сетки из ромбов.</em></p>\n<p>Ниже изображение которое мы будем использовать.</p>\n<p><img src=\"img/1__cgjmu9C__VdX1ydQ__XCqWNg.jpeg\"></p>\n<p>А это то, к чему мы стремимся. По наведению на один из трех нижних блоков, вы увидите что фоновый цвет постепенно исчезает и появляется фон.</p>\n<p><img src=\"img%5C1__AQ8O0fH1lnjb__ENCtAODoA.jpeg\"></p>\n<p>Актуальный размер изображения составляет 600 × 600 пикселей. Значит, давайте начнем с четырех пустых дивов по 300 пикселей каждый и применим к ним одинаковое фоновое изображение. Еще добавим родительский контейнер размером 604 пикселя и разместим изображения с применением свойства `inline-block`.</p>\n<p><img src=\"img%5C1__ULTvyvMYFrVwGXaR9e9ZMw.jpeg\"></p>\n<p>Теперь, изменим значение свойства <code class=\"language-text\">background-position</code> для каждого изображения на <code class=\"language-text\">top</code> , <code class=\"language-text\">left</code>, <code class=\"language-text\">right</code> и <code class=\"language-text\">bottom</code> , соответственно.</p>\n<p>Давайте обрежем каждый блок по фигуре ромба.</p>\n<p>Мы перекроем абсолютно спозиционированным слоем три нижних изображения, с небольшим текстом.</p>\n<p><img src=\"img%5C1__iNCPS7DGZkyR0RiCfLhGng.jpeg\"></p>\n<p>Теперь переместим изображения в строки — второе и третье изображение в одну строку, а первое и четвертое изображение в собственные индивидуальные строки.</p>\n<p><img src=\"img%5C1__Ce1Ec6u04cWHIed6mVdkqQ.jpeg\"></p>\n<p>Наконец, используем отрицательные <code class=\"language-text\">margins</code> чтобы поднять вторую и третью строки, таким образом они будут располагаться как в примере ниже. Мы можем удалить значение ширины родительского контейнера 604 пикселя, и назначить медиа запросы, чтобы блоки ромбов менялись от расположения в колонку на маленьких экранах, до расположения в строку на экранах побольше.</p>\n<p>Работая над эти примером, я заметила баг в Chrome с направленным <code class=\"language-text\">pointer-events</code> вне обрезанной области, что является нарушением спецификации: “По умолчанию, <code class=\"language-text\">pointer-events</code> не должно ссылаться на отсеченные (неотображаемые) области фигуры.” Я получила ошибку. Проблема в этом примере решена использованием свойства <code class=\"language-text\">pointer-events</code> со значением <code class=\"language-text\">none</code> для слоя наложения. В качестве альтернативы, вы можете применить такое же значение <code class=\"language-text\">clip-path</code> для слоя наложения. Чтобы решить проблему.</p>\n<p>Из-за применения отрицательных отступов, этот пример может выглядеть странно в браузерах, не поддерживающих <code class=\"language-text\">clip-path</code>. Вам нужно использовать что-то типа проверки возможности использования <code class=\"language-text\">clip-path</code> для применения отступов (хотя, я этого не пробовала) или использовать запрос для CSS <a href=\"http://twitter.com/supports\" title=\"Twitter profile for @supports\">@supports</a>, хотя последнее я не рекомендую использовать в продакшене.</p>\n<p><em>Пример 5: Делаем глупую страничку профиля с шестиугольниками.</em></p>\n<p>В результате наша страница должна выглядеть так:</p>\n<p><img src=\"img%5C1__iwBoRGxM__grZrb2sOC6V1A.jpeg\"></p>\n<p>Начнем с добавления фонового изображения из шестиугольных плиток для <code class=\"language-text\">body</code> (спасибо за изображение Subtle Patterns).</p>\n<p>Значения шестиугольника для <code class=\"language-text\">clip-path</code> могут быть получены из примеров ниже или с помощью Clippy tool.</p>\n<p>Первый шестиугольник использует фоновое изображение (т.к. мы подмешиваем скучный бордовый в фон используя свойство <code class=\"language-text\">background-blend-mode</code>). Используя полученное содержимое, абсолютно спозиционированный перекрывающий слой обрезается до бордового треугольника, который вы видите внизу. Он исчезает при наведении курсора.</p>\n<p>Второй шестиугольник, со словом “work,” просто содержит серый фон, который меняется при наведении.</p>\n<p>У третьего шестиугольника есть граница с градиентом, так же как и в одном из примеров с созданием границ с помощью <code class=\"language-text\">clip-path</code>.</p>\n<p>Шестиугольники складываются на маленьких экранах и центрируются по вертикали на экранах побольше. Я использовала комбинацию свойства <code class=\"language-text\">display</code> : <code class=\"language-text\">table</code> и хака для абсолютного центрирования — конечно, вы можете использовать <code class=\"language-text\">flexbox</code>, <code class=\"language-text\">floats</code> или что-то еще, что поможет удержать ваш корабль верстки “на плаву”.</p>\n<p>Вот итоговый пример кода.</p>\n<p>Я обнаружила баг <code class=\"language-text\">clip-path</code> при создании этого примера. Изменение значения свойства <code class=\"language-text\">opacity</code> в сочетании с переходами CSS провоцирует мигание и артефакты на странице. Избегайте этого, если вы используете <code class=\"language-text\">clip-path</code> чтобы улучшить дизайн.</p>\n<p>Также есть проблема при использовании <code class=\"language-text\">clip-path</code> и свойства <code class=\"language-text\">backface-visibility</code> если его установить в значение <code class=\"language-text\">hidden</code>. Этот баг указан в баг трекере Chromium и мне удалось его воспроизвести используя основной синтаксис для фигур в Chrome на Linux. Помните об этом если используете <code class=\"language-text\">clip-path</code> фигуру для создания крутого 3D поворота или чего нибудь, что использует 3D трансформации CSS.</p>\n<p>Обрезка с помощью SVG без труда побеждает из-за ее гибкости иnи вариаций, но ничто не сравнится с легкостью,с которой элемент может быть обрезан с помощью CSS. Фактически, те же координаты для многоугольника могут быть играючи преобразованы для создания отзывчивого SVG и лучшей поддержки браузерами. С <code class=\"language-text\">clip-path</code>, вы можете кардинально менять вид и поведение страницы, не слишком волнуясь о поддержке браузерами, где она ухудшена. При выборе <code class=\"language-text\">clip-path</code> для улучшения дизайна, следите за статусом спецификации, возможно она продвинется до статуса “Recommendation”.</p>\n<p>Ресурсы, Инструменты и Вдохновение</p>\n<ul>\n<li><a href=\"http://www.w3.org/TR/css-masking-1\">CSS Masking Module Level 1</a> W3C лучший источник истины при возникновении сомнений.</li>\n<li><a href=\"http://sarasoueidan.com/blog/css-svg-clipping\">Clipping in CSS and SVG: The clip-path Property and `<clipPath>` Element</a> Подробное руководство Sara Soueidan по обрезке фигур. Т.к. по большей части там фокусируются на SVG, эта статья — фантастическое введение, с достаточным количеством информации даже для продвинутых читателей.</li>\n<li><a href=\"http://tympanus.net/codrops/css_reference/clip-path\">clip-path</a> статья Sara Soueidan для Codrops — тщательно проработанное и исчерпывающее руководство разбивает реально сложные модули на то что легко понять и усвоить.</li>\n<li><a href=\"http://css-tricks.com/clipping-masking-css/\">Clipping and Masking in CSS</a> статья Chris Coyier на CSS-Tricks снабженная несколькими полезными примерами, объясняющими как клиппирование так и маскирование.</li>\n<li><a href=\"http://bennettfeely.com/clippy\">Clippy</a> инструмент от Bennett Feely для создания clip-path может генерировать множество предустановленных и кастомных многоугольников, кругов и эллипсов для CSS clip-path. Все значения указаны в процентах, следовательно, это будет полезно при создании адаптивной верстки.</li>\n<li><a href=\"http://cssplant.com/clip-path-generator\">Clip Path Generator CSS Plant</a> предоставляет более исчерпывающий графический интерфейс для применения клиппирования или маскирования элементов. Браузерная поддержка реализована для Firefox, Chrome, Safari и старых iOS. Размеры в пикселях, не в процентах.</li>\n<li><a href=\"http://www.species-in-pieces.com/\">Species in Pieces</a> Захватывающая дух, демонстрация из 30 исчезающих видов была разработана полностью с помощью CSS’ <code class=\"language-text\">clip-path</code>, без помощи <code class=\"language-text\">canvas</code> или <code class=\"language-text\">WebGL</code>. Пока остальные браузеры не подхватятся смотрите ее в WebKit или Blink браузерах.</li>\n</ul>","fields":{"slug":"/pages/posts/responsive-shapes-with-clip-path/"},"frontmatter":{"title":"Создаем крутые фигуры с помощью Clip-Path и разбиваем привычную боксовую модель.","date":"16 December, 2018","tags":["css"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/pages/posts/responsive-shapes-with-clip-path/"}}}